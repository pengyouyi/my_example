[TOC]

# 1. 两数之和【9/16】

[https://leetcode-cn.com/problems/two-sum/](https://leetcode-cn.com/problems/two-sum/)

给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。

你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。

**示例:**

给定 nums = [2, 7, 11, 15], target = 9

因为 nums[0] + nums[1] = 2 + 7 = 9

所以返回 [0, 1]

**Answer**

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(nums, target) {
    const len = nums.length;
    for(let i = 0; i < len - 1; i++) {
        for(let j = i + 1; j < len; j++) {
            if(nums[i] + nums[j] === target) {
                return [i,j];
            }
        }
    }
};
```

# 7. 整数反转

[https://leetcode-cn.com/problems/reverse-integer/](https://leetcode-cn.com/problems/reverse-integer/)

给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。

**示例 1:**

> 输入: 123
> 输出: 321

**示例 2:**

> 输入: -123
> 输出: -321

**示例 3:**

> 输入: 120
> 输出: 21

**注意:**

假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。

**Answer**

*法一：数字转化成字符串 + 数组的reverse方法*
```js
/**
 * @param {number} x
 * @return {number}
 */
 /*法一：借鉴数组的reverse方法*/
var reverse = function(x) {

    var arr = [];
    var stringX = String(x);
    var len = stringX.length;
    var newNum;

    for(let i = 0; i < len; i++) {
        arr.push(stringX[i])
    }
    
    if (stringX < 0) {
        arr.splice(0,1);
        arr.reverse();
        newNum  = Number('-' + arr.join(''))
    } else {
        arr.reverse();
        newNum = Number(arr.join(''))
    }

    if (newNum > 2147483647 || newNum < -2147483648) {
        return 0;
    } 
    return newNum;
    
};

var x = -5428514;
console.log(reverse(x))

```

*法二：数组存储每次的商【最高位上的数】*
```js
/*法二：数组存储每次的商【最高位上的数】*/
var reverse2 = function(x) {
    var flag = true;
    if (x < 0) { 
        flag = false;
    }
    var absX = Math.abs(x);
    // 被除数
    var divIdendX = absX;
    var i = absX.toString().length;
    var tempArr = [];
    var result;

   while(divIdendX > 0) {
        // 商
        var quotient = Math.floor(divIdendX / Math.pow(10,--i))
        divIdendX = divIdendX % Math.pow(10,i)

        tempArr.push(quotient)
    }

    tempArr.reverse();

    if (flag) {
        result = Number(tempArr.join(''))
    } else {
        result =  Number('-' + tempArr.join(''))
    }

    if (result > 2147483647 || result < -2147483648) {
        return 0;
    } 

    return result

}
var x = -5428514;
console.log(reverse2(x))

```

*法三：字符串拼接每次的余数【最低位上的数】*
```js

/*法三：字符串拼接每次的余数【最低位上的数】*/
var reverse3 = function(x) {

    var absX = Math.abs(x);
    // 被除数
    var divIdendX = absX;
    var l = absX.toString().length;
    var result = '';
    var i = 0;
    var quotient;

   while(i < l) {
        
        // 余数,每次个位数
        quotient = divIdendX % 10;
        //quotient = divIdendX.toString().substr(-1,1)
        
        divIdendX = Math.floor(divIdendX / 10)
        
        i++;

        result += quotient;
    }

    if (x < 0) {
        result = "-" + result;
    } 

    if (result > 2147483647 || result < -2147483648) {
        return 0;
    } 

    return result;

}
```

# 9. 回文数

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

**示例 1:**

> 输入: 121
> 输出: true

**示例 2:**

> 输入: -121
> 输出: false

解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

**示例 3:**

> 输入: 10
> 输出: false

解释: 从右向左读, 为 01 。因此它不是一个回文数。

**进阶:**

你能不将整数转为字符串来解决这个问题吗？

**Answer**

*法一：利用字符串*

```js
/**
 * @param {number} x
 * @return {boolean}
 */
/*法一：转化成字符串，比较字符串首尾是否一样*/
var isPalindrome = function(x) {
    var StrX = x.toString();
    var len = StrX.length;
    var flag;
    for(let i = 0; i <= Math.floor(len/2); i++) {
        if(StrX[i] === StrX[len-i-1]) {
            flag = true
        } else {
            flag = false
            return flag
        }   
    }
    return flag;
};

var x = -132231;

console.log(isPalindrome(x))
```

*法二：利用数组反转*

```js
/*法二：利用数组反转。比较慢，不建议，*/

var isPalindrome2 = function(x) {
    var StrX = x.toString();
    var flag;
    if (x < 0) {
        flag = false;
        return flag;
    }

    var reverseStrX = StrX.split('').reverse().join('');
    
    if(StrX === reverseStrX) {
        flag = true
    } else {
        flag = false
    }
    return flag;
};

console.log(isPalindrome2(x))
```

# 13. 罗马数字转整数

罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。

|字符 |         数值|
|---|---|
|I|             1|
|V|             5|
|X|             10|
|L|             50|
|C|             100|
|D|             500|
|M|             1000|

例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。

通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：

- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 
- C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。

**示例 1:**

> 输入: "III"
> 输出: 3

**示例 2:**

> 输入: "IV"
> 输出: 4

**示例 3:**

> 输入: "IX"
> 输出: 9

**示例 4:**

> 输入: "LVIII"
> 输出: 58

解释: L = 50, V= 5, III = 3.

**示例 5:**

> 输入: "MCMXCIV"
> 输出: 1994

解释: M = 1000, CM = 900, XC = 90, IV = 4.


**Answer**

*法一：switch语句*
```js
var romanToInt = function(s) {
    var result = 0;
    var len = s.length;
    for( let i = 0; i < len; i++) {
        switch(s[i]) {
            case 'I':
                if (s[i + 1] === 'V') {
                    result += 4;
                    i++
                } else if (s[i + 1] === 'X') {
                    result += 9;
                    i++
                } else {
                   result += 1; 
                }
                break;
            case 'V':
                result += 5;
                break;
            case 'X':
                if (s[i + 1] === 'L') {
                    result += 40;
                    i++
                } else if (s[i + 1] === 'C') {
                    result += 90;
                    i++
                } else {
                   result += 10; 
                }
                break;
            case 'L':
                result += 50;
                break;
            case 'C':
                if (s[i + 1] === 'D') {
                    result += 400;
                    i++
                } else if (s[i + 1] === 'M') {
                    result += 900;
                    i++
                } else {
                   result += 100; 
                }
                break;
            case 'D':
                result += 500;
                break;
            case 'M':
                result += 1000;
                break;
            default:
                result += 0;
                break;
        }
    }
    return result;
}
console.log(romanToInt(s))
```

*法二：将两位罗马数字转成一位*
```js
var romanToInt2 = function(s) {

    s = s.replace(/IV/g, 'Q'); //4
    s = s.replace(/IX/g, 'W'); //9
    s = s.replace(/XL/g, 'E'); //40
    s = s.replace(/XC/g, 'R'); //90
    s = s.replace(/CD/g, 'T'); //400
    s = s.replace(/CM/g, 'Y'); //900
    var map = {
        "I": 1,
        "V": 5,
        "X": 10,
        "L": 50,
        "C": 100,
        "D": 500,
        "M": 1000,
        "Q": 4,
        "W": 9,
        "E": 40,
        "R": 90,
        "T": 400,
        "Y": 900,
    };
    var len = s.length;
    var result = 0;
    for(var i in s) {
        result += map[s[i]]
    }
    return result
}

console.log(romanToInt2(s))
```

# 14. 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 ""。

**示例 1:**

> 输入: ["flower","flow","flight"]
> 输出: "fl"

**示例 2:**

> 输入: ["dog","racecar","car"]
> 输出: ""

解释: 输入不存在公共前缀。

**说明:**

所有输入只包含小写字母 a-z 。

**Answer**

```js
/**
 * @param {string[]} strs
 * @return {string}
 */
var longestCommonPrefix = function(strs) {
    var result = '';
    var len = strs.length;
    if (!len) {
        return result;
    }
    if (strs.length == 1) {
        return strs[0]
    };
    var firstLen = strs[0].length;
    for(let i = 0; i < firstLen; i++) {
        for (let k = 1; k < len; k++) {
            if(strs[0][i] !==  strs[k][i]) {
                return result;
            }
        }  
        result += strs[0][i]
    }
    return result;
};

var strs = ["flower","flow","floight"];
//var strs = ["dog","racecar","car"]

console.log(longestCommonPrefix(strs))
```

# 20. 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。

2. 左括号必须以正确的顺序闭合。

注意空字符串可被认为是有效字符串。

**示例 1:**

> 输入: "()"
> 输出: true

**示例 2:**

> 输入: "()[]{}"
> 输出: true

**示例 3:**

> 输入: "(]"
> 输出: false

**示例 4:**

> 输入: "([)]"
> 输出: false

**示例 5:**

> 输入: "{[]}"
> 输出: true

**Answer**

*法一：从最内层一层一层消去括号对，全部消除说明字符串有效*
```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isValid = function(s) {

    if (s.length % 2 !== 0) {
        return false;
    }

    while((s.indexOf('()') != -1) || (s.indexOf('[]') != -1) || (s.indexOf('{}') != -1)) {
        s = s.replace('()','')
        s = s.replace('[]','')
        s = s.replace('{}','')
    }
    
    return s === '';
};

var s = "{[]}()"

console.log(isValid(s))
```

*法二：边遍历边匹配。*

也就是遍历的时候遇到左括号存入数组，下次遇到的第一个右括号必须和数组中最后一个元素匹配，否则为无效字符串，匹配完成后从数组中删除此元素。若最终数组为空，表示括号已全部匹配完，字符串有效。

```js
    var isValid2 = function(s) {
    var len = s.length;
    if ( len % 2 !== 0) {
        return false;
    }
    var leftArr = [];
    var map = {
        '(' : ')',
        '[' : ']',
        '{' : '}'
    };
    for (var i of s) {
        if (i in map) {
            leftArr.push(i); //为左括号时，顺序保存
        } else {
            if(i !== map[leftArr.pop()]) { //为右括号时，与数组末位匹配
                return false; 
            }
        }  
    }
    return !leftArr.length; //防止全部为左括号
}
console.log(isValid2(s))
```

# 21. 合并两个有序链表

将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

**示例：**

> 输入：1->2->4, 1->3->4
> 输出：1->1->2->3->4->4

**Answer**

待添加。。。

# 26. 删除排序数组中的重复项

给定一个排序数组，你需要在`原地`删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

**示例 1:**

给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。

**示例 2:**

给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```js
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

**Answer**

*法一*

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function(nums) {
    var len = nums.length;
    for(let i = len; i > 0; i--) {
        if(nums[i] === nums[i-1]) {
        	nums.splice(i-1, 1);
        }
    }
    return nums.length;
};
var nums = [0,0,1,1,1,2,2,3,3,4,6];
console.log(removeDuplicates(nums))
```

*法二*

```js
var removeDuplicates2 = function(nums) {
    // var len = nums.length;
    // var index = 0;
    // for(let i = 0; i < len; i++) {
    //     if(nums[i] !== nums[i + 1]) {
    //     	nums[index] = nums[i];
    //     	index++;
    //     }
    // }
    // return index;
    var len = 1;
    for (var i = 1; i < nums.length; i++) {
        if (nums[i] != nums[i-1]) {
        	nums[len++] = nums[i];
        }
    }
    return len

};
```

# 27. 移除元素

给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

**示例 1:**


给定 nums = [3,2,2,3], val = 3,

函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。

你不需要考虑数组中超出新长度后面的元素。

**示例 2:**

给定 nums = [0,1,2,2,3,0,4,2], val = 2,

函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。

注意这五个元素可为任意顺序。

你不需要考虑数组中超出新长度后面的元素。

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}

**Answer**

*法一：splice方法*
```js
/**
 * @param {number[]} nums
 * @param {number} val
 * @return {number}
 */
var removeElement = function(nums, val) {
    var len = nums.length;
    for (var i = len - 1; i >= 0; i--) {
        if (nums[i] === val) {
            nums.splice(i,1)
        }
    }
    return nums.length;
};
var nums = [0,1,2,2,3,0,4,2];
var val = 2;
console.log(removeElement(nums, val))
```

*法二：直接修改数组*

```js
var removeElement2 = function(nums, val) {
    var len = nums.length;
    var index = 0;
    for (var i = 0; i < len; i++) {
        if (nums[i] !== val) {
            nums[index] = nums[i];
            index++;
        }
    }
    return index;
};
console.log(removeElement2(nums, val))
```

# 28. 实现 strStr()

实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

**示例 1:**

> 输入: haystack = "hello", needle = "ll"
> 输出: 2

**示例 2:**

> 输入: haystack = "aaaaa", needle = "bba"
> 输出: -1

**说明:**

当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

**Answer**

*法一：字符串现成的indexOf()方法*
```js
/**
 * @param {string} haystack
 * @param {string} needle
 * @return {number}
 */
var strStr = function(haystack, needle) {
    return haystack.indexOf(needle)
};
var haystack = "hello";
var needle = "ll";
console.log(strStr(haystack, needle))
```

*法二：借鉴字符串的substr方法*
```js
var strStr2 = function(haystack, needle) {
    var len = haystack.length;
    var needleLen = needle.length;
    if (needle === '') {
        return 0;
    }
    for (var i = 0; i < len; i++) {
        if (haystack[i] === needle[0]) {
            if (haystack.substr(i,needleLen) === needle) {
                return i;
            }
        }
    }
    return -1;
};
console.log(strStr2(haystack, needle))
```

# 35. 搜索插入位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

**示例 1:**

> 输入: [1,3,5,6], 5
> 输出: 2

**示例 2:**

> 输入: [1,3,5,6], 2
> 输出: 1

**示例 3:**

> 输入: [1,3,5,6], 7
> 输出: 4

**示例 4:**

> 输入: [1,3,5,6], 0
> 输出: 0

**Answer**

*法一：挨个比对*

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var searchInsert = function(nums, target) {
    var len = nums.length;
    if (len === 0) {
        return 0;
    }
    for (var i = 0; i < len; i++) {
        if(nums[i] >= target) {
            return i;
        }
    }
    if (target > nums[len-1]) {
        return len;
    }
};
var nums = [1,3,5,6];
var target = 0;
console.log(searchInsert(nums, target))
```

*法二：二分查找*

待添加。。。

## 53. 最大子序和

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**示例:**

> 输入: [-2,1,-3,4,-1,2,1,-5,4],
> 输出: 6

解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

**进阶:**

如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。

**Answer**

*法一*
```js
var maxSubArray = function(nums) {

    let result = nums[0];
    let sum = 0;
    
    for (let item of nums) {
        //if (sum > 0) {
        if (sum + item > item) {
            sum = sum + item
        } else {
            sum = item
        }
        result = Math.max(result, sum)
    }
    return result
};

var nums = [-2,1,-3,4,-1,2,1,-5,4];

console.log(maxSubArray(nums))
```

# 58. 最后一个单词的长度

给定一个仅包含大小写字母和空格 ' ' 的字符串，返回其最后一个单词的长度。

如果不存在最后一个单词，请返回 0 。

说明：一个单词是指由字母组成，但不包含任何空格的字符串。

**示例:**

> 输入: "Hello World"
> 输出: 5

**Answer**

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLastWord = function(s) {
    let trimS = s.trim();
    let sToArr = trimS.split(/\s+/);
    let len = sToArr.length;
    return sToArr[len - 1].length;
};
var s = "Hello  World ";
console.log(lengthOfLastWord(s))
```

# 66. 加一

给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。

最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。

你可以假设除了整数 0 之外，这个整数不会以零开头。

**示例 1:**

> 输入: [1,2,3]
> 输出: [1,2,4]

解释: 输入数组表示数字 123。

**示例 2:**

> 输入: [4,3,2,1]
> 输出: [4,3,2,2]

解释: 输入数组表示数字 4321。

**Answer**

1. 末位无进位，则末位加一即可，因为末位无进位，前面也不可能产生进位，比如 45 => 46

2. 末位有进位，在中间位置进位停止，则需要找到进位的典型标志，即为当前位 %10后为 0，则前一位加 1，直到不为 0 为止，比如 499 => 500

3. 末位有进位，并且一直进位到最前方导致结果多出一位，对于这种情况，需要在第 2 种情况遍历结束的基础上，进行单独处理，比如 999 => 1000


*法一：数组转化成Number，再加一，缺点，数组太长造成数字溢出，故舍去*


*法二：从后往前判断每位数是否为9*

```js
/**
 * @param {number[]} digits
 * @return {number[]}
 */
var plusOne = function(digits) {

    var len = digits.length;
    for(var i = len - 1;i >= 0;i--){
        if (digits[i] != 9){
            digits[i]++;
            break;
        }
        else {
            digits[i] = 0;
            if (i === 0) {
            	digits.unshift(1)
            }
        }
    }
    return digits
};

//var digits = [6,1,4,5,3,9,0,1,9,5,1,8,6,7,0,5,5,4,3];
var digits = [9,9];
console.log(plusOne(digits))
```

# 67. 二进制求和

给定两个二进制字符串，返回他们的和（用二进制表示）。

输入为非空字符串且只包含数字 1 和 0。

**示例 1:**

> 输入: a = "11", b = "1"
> 输出: "100"

**示例 2:**

> 输入: a = "1010", b = "1011"
> 输出: "10101"

**Answer**

*法一：二进制转十进制再转二进制，字符串太长，依然会碰到溢出的情况，故舍去*

```js
var addBinary = function(a, b) {
    var sum = parseInt(a,2) + parseInt(b,2)
    return sum.toString(2)
};
```

*法二：字符串左边padStart先补零，然后字符串相加，满二进一留零，满三进一留一*

```js
/**
 * @param {string} a
 * @param {string} b
 * @return {string}
 */
var addBinary = function(a, b) {
    var maxLen = Math.max(a.length,b.length);
    a = a.padStart(maxLen, '0')
    b = b.padStart(maxLen, '0')
    var temp = [];
    for(var i = 0; i < maxLen; i++) {
        temp.push(parseInt(a[i]) + parseInt(b[i]))
    }
    for(var j = maxLen - 1; j > 0; j--) {
        if(temp[j] == 2) {
            temp[j] = 0;
            temp[j-1] = temp[j-1] + 1;
        } else if (temp[j] == 3) {
            temp[j] = 1;
            temp[j-1] = temp[j-1] + 1;
        }
    }
    if(temp[0] == 2) {
        temp.splice(0,1,1,0);
    }
    if(temp[0] == 3) {
        temp.splice(0,1,1,1);
    }
    return temp.join('')
};

var a = '1111';
var b = '1111'
console.log(addBinary(a,b))
```

# 69. x 的平方根

实现 int sqrt(int x) 函数。

计算并返回 x 的平方根，其中 x 是非负整数。

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。

**示例 1:**

> 输入: 4
> 输出: 2

**示例 2:**

> 输入: 8
> 输出: 2

*说明:*

8 的平方根是 2.82842..., 
由于返回类型是整数，小数部分将被舍去。

**Answer**

*法一：推荐*
```js
/**
 * @param {number} x
 * @return {number}
 */
var mySqrt = function(x) {
   return parseInt(Math.sqrt(x)) 
};

var x = 10;
console.log(mySqrt(x))
```

*法二：缺点：慢*
```js
var mySqrt2 = function(x) {
    var i = 0;
    while(!(i*i<=x && (i+1)*(i+1)>x)){
        i++;
    }
    return i
};
console.log(mySqrt2(x))
```

# 70. 爬楼梯

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

注意：给定 n 是一个正整数。

**示例 1：**

> 输入： 2
> 输出： 2

解释： 
有两种方法可以爬到楼顶。
1.  1 阶 + 1 阶
2.  2 阶

**示例 2：**

> 输入： 3
> 输出： 3

解释： 
有三种方法可以爬到楼顶。
1.  1 阶 + 1 阶 + 1 阶
2.  1 阶 + 2 阶
3.  2 阶 + 1 阶

**Answer**

|n阶楼梯|上楼梯种数|
|---|---|
|1|1|
|2|2|
|3|3|
|4|5|
|5|8|
|6|13|

**题目理解**

- 有n层楼梯，最后可以爬一层或者二层。
- a、如果最后爬一层，前面还有（n-1）层未爬，总共有f(n-1)种方法；
- b、如果最后爬两层，前面还有（n-2）层未爬，总共有f(n-2)种方法；
- 因此，总共有 f(n-1) + f(n-2) 种方法，
- 即f(n) = f(n-1) + f(n-2) 


*法一：递归*

缺点：n太大会超出时间限制，故不可取

```js
/**
 * @param {number} n
 * @return {number}
 */
var climbStairs = function(n) {
    if(n <= 2) {
    	return n;
    } else {
    	return climbStairs(n-1) + climbStairs(n-2)
    }
};

var n = 45;
console.log(climbStairs(n))
```

*法二:动态规划*

```js
var climbStairs2 = function(n) {
    let result = new Array(n+1);
	result[1] = 1; //到第一阶有1种
	result[2] = 2; //到第二阶有2种

	for(let i = 3; i < n+1; i++){
		result[i] = result[i-1] + result[i-2];
	}

	return result[n];
}
```

# 88. 合并两个有序数组

给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。

说明:

初始化 nums1 和 nums2 的元素数量分别为 m 和 n。
你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。
示例:

> 输入:
nums1 = [1,2,3,0,0,0], m = 3
nums2 = [2,5,6],       n = 3

> 输出: [1,2,2,3,5,6]

**Answer**

*法一：forEach方法最快*
```js
/**
 * @param {number[]} nums1
 * @param {number} m
 * @param {number[]} nums2
 * @param {number} n
 * @return {void} Do not return anything, modify nums1 in-place instead.
 */
var merge = function(nums1, m, nums2, n) {
    nums1.length = m;
    nums2.length = n;
    nums2.forEach((item,index) => {
    	return nums1.push(item)
    });
    nums1.sort( (a,b) =>  a - b );
    return nums1
};

var nums1 = [1,2,3,0,0,0];
var m = 3;
var nums2 = [2,5,6];       
var n = 3;

// console.log(merge(nums1, m, nums2, n))
```

*法二：apply方法比forEach慢很多*
```js
var merge2 = function(nums1, m, nums2, n) {
    nums1.splice(m, nums1.length - m)
    nums2.splice(n, nums2.length - n)
    nums1.push.apply(nums1,nums2);
    nums1.sort( (a,b) =>  a - b );
    return nums1
};

//console.log(merge2(nums1, m, nums2, n))
```

*法三*
```js
var merge3 = function(nums1, m, nums2, n) {
    var len = nums2.length;
    for( var i = 0; i < len; i++) {
        nums1[m+i] = nums2[i]
    }
    nums1.sort( (a,b) =>  a - b );
    return nums1
};

console.log(merge3(nums1, m, nums2, n))
```

*法四：双指针*

待补充。。。

# 100. 相同的树

给定两个二叉树，编写一个函数来检验它们是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

**示例 1:**

```js
输入:       1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

输出: true
```

**示例 2:**

```js
输入:      1          1
          /           \
         2             2

        [1,2],     [1,null,2]

输出: false
```

**示例 3:**

```js
输入:       1         1
          / \       / \
         2   1     1   2

        [1,2,1],   [1,1,2]

输出: false
```

**Answer**

深度优先遍历

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {boolean}
 */
var isSameTree = function(p, q) {
    if(p == null && q == null) 
        return true;
    if(p == null || q == null) 
        return false;
    if(p.val != q.val) 
        return false;
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
};
```

# 101. 对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

例如，二叉树 [1,2,2,3,4,4,3] 是对称的。

```js
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:

```js
    1
   / \
  2   2
   \   \
   3    3
```

说明:

如果你可以运用递归和迭代两种方法解决这个问题，会很加分。

**Answer**

递归

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {boolean}
 */
var isSymmetric = function(root) {
    if (root === null) return true;
    return help(root.left, root.right);
};

function help(left, right) {
    if (left === null && right === null) {
        return true;
    }
    if (left === null || right === null) {
        return false;
    }
    
    return left.val === right.val && help(left.left, right.right) && help(left.right, right.left);
}
```

# 104. 二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

**示例：**

给定二叉树 [3,9,20,null,null,15,7]，

```js

    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3 。

**Answer**

```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var maxDepth = function(root) {
    if(!root) {
        return 0;
    } else {
        const left = maxDepth(root.left);
        const right = maxDepth(root.right);
        return Math.max(left, right) + 1;
    }
};
```

# 118. 杨辉三角

给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。

![](https://upload.wikimedia.org/wikipedia/commons/0/0d/PascalTriangleAnimated2.gif)

在杨辉三角中，每个数是它左上方和右上方的数的和。

**示例:**

> 输入: 5
> 输出:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]

**Answer**

```js
/**
 * @param {number} numRows
 * @return {number[][]}
 */
var generate = function(numRows) {

    var result = [];

    for (var i = 1; i <= numRows; i++) {
        var row = [];

        for (var j = 0; j < i; j++) {
            if(j == 0 || j == i - 1) {
                row.push(1);
            } else {
                row.push(result[i-2][j-1] + result[i-2][j]);
            }
        }
        result.push(row)
    }

    return result;
};

var numRows = 6;
console.log(generate(numRows))
```

# 121. 买卖股票的最佳时机

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。

注意你不能在买入股票前卖出股票。

**示例 1:**

> 输入: [7,1,5,3,6,4]
> 输出: 5
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。
注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。

**示例 2:**

> 输入: [7,6,4,3,1]
> 输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

**Answer**


*法一：暴力双循环*

缺点：速度太慢，被吊打

```js
/**
 * @param {number[]} prices
 * @return {number}
 */
var maxProfit = function(prices) {
    var len = prices.length;
    var result = [];
    for(var i = 0; i < len-1; i++) {
        for(var j = i+1; j < len; j++) {
            if(prices[j] > prices[i]) {
                result.push(prices[j] - prices[i])
            }
        }
    }
    var max = Math.max.apply(null,result);
    if(result.length == 0) {
        return 0
    }
    return max;
};

var prices = [7,1,5,3,6,4];
console.log(maxProfit(prices))
```

*法二：动态规划*

前i天的最大收益 = max{前i-1天的最大收益，第i天的价格-前i-1天中的最小价格}

1.	记录【今天之前买入的最小值】

2.	计算【今天之前最小值买入，今天卖出的获利】，也即【今天卖出的最大获利】

3.	比较【每天的最大获利】，取最大值即可


```js
var maxProfit2 = function(prices) {
    var len = prices.length;
    if (len <= 1) {
        return 0;
    }
    var min = prices[0];
    var max = 0;
    for(var i = 1; i < len; i++) {
        if (prices[i] > prices[i-1]) {
            max = Math.max(max,prices[i] - min);
        } else {
            min = Math.min(min, prices[i])
        }   
    }
    return max;
};
```

## 122. 买卖股票的最佳时机 II

给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。

设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。

注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

**示例 1:**

> 输入: [7,1,5,3,6,4]
> 输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

**示例 2:**

> 输入: [1,2,3,4,5]
> 输出: 4
解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。
     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

**示例 3:**

> 输入: [7,6,4,3,1]
> 输出: 0
解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。

**Answer**

*法一：贪心算法*

一次遍历，只要今天价格小于明天价格就在今天买入然后明天卖出，时间复杂度O(n)

```js
/**
@param {number[]} prices
@return {number}
*/
var maxProfit = function(prices) {
    var profit = 0;
    var min = prices[0];
    for (var i = 0; i < prices.length; i++){
        if(prices[i] > prices[i-1]){
            profit += prices[i] - prices[i-1];
        }
    }
    return profit;
};

var prices = [7,1,5,3,6,4];

console.log(maxProfit(prices))
```

*法二：DP动态规划*

第i天只有两种状态，不持有或持有股票，当天不持有股票的状态可能来自昨天卖出或者昨天也不持有，同理，当天持有股票的状态可能来自昨天买入或者昨天也持有中，取最后一天的不持有股票状态就是问题的解

待补充。。。

# 125. 验证回文串

给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。

说明：本题中，我们将空字符串定义为有效的回文串。

**示例 1:**

> 输入: "A man, a plan, a canal: Panama"
> 输出: true

**示例 2:**

> 输入: "race a car"
> 输出: false


**Answer**

*法一：循环，比较首尾字符*

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var isPalindrome = function(s) {
    if (s == null || s.length == 0) {
        return true;
    }
    s = s.replace(/[^0-9a-zA-Z]/g, '').toLowerCase();
    var len = s.length;
    var middle = Math.floor((len-1)/2);
    for(var i = 0; i <= middle; i++) {
        if(s[i] !== s[len-1-i]) {
            return false
        }
    }
    return true;
};

var s = "A man, a plan, a canal: Panama";
console.log(isPalindrome(s))
```

*法二：双指针，思想同法一，比法一慢点*

```js
var isPalindrome3 = function(s) {
    s = s.replace(/[^a-zA-Z0-9]/g,"").toLowerCase();
    let i = 0,j = s.length - 1;
    while (i < j) {
        if(s[i] !== s[j]){
           return false;
        }
        i++;
        j--;
    }
    return true;
};
```

*法三：借助数组reverse()方法*

速度较快，不过耗内存

```js
var isPalindrome2 = function(s) {
    if (s == null || s.length == 0) {
        return true;
    }
    s = s.replace(/[^0-9a-zA-Z]/g, '').toLowerCase();
    var s2 = s.split('').reverse().join('');
    return s === s2;
};
```

# 136. 只出现一次的数字

给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

说明：

你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

**示例 1:**

> 输入: [2,2,1]
> 输出: 1

**示例 2:**

> 输入: [4,1,2,1,2]
> 输出: 4


**Answer**

*法一：排序再循环比较*

排序后只要某一项与它的前一项不同且与它的后一项也不同那它就是唯一项

```js
var singleNumber = function(nums) {
    nums.sort( (a, b) => a - b);
    for(let i = 0; i < nums.length; i++) {
        if(nums[i] !== nums[i-1] && nums[i] !== nums[i+1]) {
            return nums[i]
        }
    }
};
```

*法二：位运算 异或*

1.	交换律：a ^ b ^ c <=> a ^ c ^ b 
2.	任何数于0异或为任何数 0 ^ n => n 
3.	相同的数异或为0: n ^ n => 0 
var a = [2,3,2,4,4]
2 ^ 3 ^ 2 ^ 4 ^ 4等价于 2 ^ 2 ^ 4 ^ 4 ^ 3 => 0 ^ 0 ^3 => 3

原理是将数组中所有数都一起异或之后值相同的项异或为0,0异或那个只出现一次的项结果为那个项本身

```js
var singleNumber2 = function(nums) {
    var result = 0;
    var len = nums.length
    for(let i = 0; i < len; i++) {
        result = result ^ nums[i];
    }
    return result
};
```

# 167. 两数之和 II - 输入有序数组

给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。

函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。

说明:

返回的下标值（index1 和 index2）不是从零开始的。
你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。
示例:

> 输入: numbers = [2, 7, 11, 15], target = 9
> 输出: [1,2]
解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

**Answer**

*法一：暴力双循环*

缺点：速度太慢

```js
/**
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function(numbers, target) {
    var len = numbers.length;
    var result = [];
    for(var i = 0; i < len - 1; i++) {
        for(var j = i + 1; j < len; j++) {
            if (numbers[i] + numbers[j] === target) {
                result.push(i+1, j+1)
            }
        }
    }
    return result
};

var numbers = [2, 7, 11, 15];
var target = 9;
console.log(twoSum(numbers, target))
```

*法二：双指针*

```js
var twoSum2 = function(numbers, target) {
    var l = 0;
    var r = numbers.length;
    while(l < r) {
        if(numbers[l] + numbers[r] === target) {
            return [l+1,r+1]
        } else if (numbers[l] + numbers[r] < target) {
            l++
        } else {
            r--
        }
    }
};
```

# 168. Excel表列名称

给定一个正整数，返回它在 Excel 表中相对应的列名称。

例如，

    1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB 
    ...

**示例 1:**

> 输入: 1
> 输出: "A"

**示例 2:**

> 输入: 28
> 输出: "AB"

**示例 3:**

> 输入: 701
> 输出: "ZY"

**Answer**

```js
/**
 * @param {number} n
 * @return {string}
 */
var convertToTitle = function(n) {
    const map = 'ZABCDEFGHIJKLMNOPQRSTUVWXYZ';
    let result = '';
    while(n) {
        let remainder = n % 26; // 余数
        result = map[remainder] + result;
        n = (n - (remainder === 0 ? 26 : remainder)) / 26; 
        //n = n % 26 === 0 ? Math.floor(n / 26) - 1 : Math.floor(n / 26)
    }
    return result;
};
var n = 1048;
console.log(convertToTitle(n))
```

# 169. 求众数

给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。

你可以假设数组是非空的，并且给定的数组总是存在众数。

**示例 1:**

> 输入: [3,2,3]
> 输出: 3

**示例 2:**

> 输入: [2,2,1,1,1,2,2]
> 输出: 2

**Answer**

*法一*

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var majorityElement = function(nums) {
    var len = nums.length;
    var obj = {};
    for (let i = 0; i < len; i++) {
        if(obj[nums[i]]) {
            obj[nums[i]]++
        } else {
            obj[nums[i]] = 1
        }
    }
    for(let k in obj) {
        if (obj[k] > len/2) {
            return k
        }
    }
};

var nums = [1,1,1,2,2];
console.log(majorityElement(nums))
```

*法二*

定义一个计数器，循环一次数组，如果循环到的数是众数(假定第一个数是众数)，那么计数器+1，否则-1，当计数器为0的时候，将下一个数作为众数。由于题目对于众数的定义是大于n/2，那么最后计数器肯定大于等于1，一定可以把众数找出来。

```js
var majorityElement2 = function(nums) {
    let count = 0
    let result = 0
    nums.forEach(item => {
        if (count === 0) result = item
        if (result !== item) count--
        if (result === item) count++
    })
    return result
};
```

# 171. Excel表列序号

给定一个Excel表格中的列名称，返回其相应的列序号。

例如，

    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28 
    ...

**示例 1:**

输入: "A"
输出: 1

**示例 2:**

输入: "AB"
输出: 28

**示例 3:**

输入: "ZY"
输出: 701

**Answer**

二十六进制转十进制

```js
/**
 * @param {string} s
 * @return {number}
 */
var titleToNumber = function(s) {
    const map = ['', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];
    var res = 0;
    var len = s.length;
    for(let i = 0; i < len; i++) {
        res += map.indexOf(s[i]) * Math.pow(26,len-i-1)
    }
    return res;
};

var s = 'ZY';
console.log(titleToNumber(s))
```

## 172. 阶乘后的零

给定一个整数 n，返回 n! 结果尾数中零的数量。

**示例 1:**

> 输入: 3
> 输出: 0
解释: 3! = 6, 尾数中没有零。

**示例 2:**

> 输入: 5
> 输出: 1
解释: 5! = 120, 尾数中有 1 个零.

说明: 你算法的时间复杂度应为 O(log n) 。

**Answer**

统计乘法因子里有多少个5。

```js
var trailingZeroes = function(n) {
	let total = 0;
    while (n >= 5) {
        n = Math.floor(n / 5);
        total += n;
    }
    return total;
};
```

# 189. 旋转数组

给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。

**示例 1:**

> 输入: [1,2,3,4,5,6,7] 和 k = 3
> 输出: [5,6,7,1,2,3,4]
解释:
向右旋转 1 步: [7,1,2,3,4,5,6]
向右旋转 2 步: [6,7,1,2,3,4,5]
向右旋转 3 步: [5,6,7,1,2,3,4]

**示例 2:**

> 输入: [-1,-100,3,99] 和 k = 2
> 输出: [3,99,-1,-100]
解释: 
向右旋转 1 步: [99,-1,-100,3]
向右旋转 2 步: [3,99,-1,-100]

**说明:**

尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。
要求使用空间复杂度为 O(1) 的 原地 算法。

**Answer**

*法一*
```js
var rotate = function(nums, k) {
    if (k == 0 || nums.length < 2) {
        return nums
    }
    var len = nums.length
    var n = k % len;
    for (let j = 0; j < n; j++) {
        nums.unshift(nums[len-1])
    }
    nums.splice(len,n);
    return nums;
};

var nums = [1,2,3,4,5,6,7];
var k = 3;
```

*法二*

```js
var rotate2 = function(nums, k) {
    if (k == 0 || nums.length < 2) {
        return nums
    }
    var len = nums.length
    var n = k % len;
    for (let j = 0; j < n; j++) {
        nums.unshift(nums.pop())
    }
    return nums;
};
```

*法三*

```js
var rotate = function(nums, k) {
    nums.splice(0, 0, ...nums.splice(nums.length - k));
};
```

# 190. 颠倒二进制位

颠倒给定的 32 位无符号整数的二进制位。

**示例 1：**

> 输入: 00000010100101000001111010011100
> 输出: 00111001011110000010100101000000
解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，
      因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。

**示例 2：**

> 输入：11111111111111111111111111111101
> 输出：10111111111111111111111111111111
解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，
      因此返回 3221225471 其二进制表示形式为 10101111110010110010011101101001。

**Answer**

```js
/**
 * @param {number} n - a positive integer
 * @return {number} - a positive integer
 */
var reverseBits = function(n) {
    var temp = n.toString(2).padStart(32,0).split('').reverse().join('');
    return Number.parseInt(temp,2);
};
var n = 00000010100101000001111010011100;
console.log(reverseBits(n))
```


# 191. 位1的个数

编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。

**示例 1：**

> 输入：00000000000000000000000000001011
> 输出：3
解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

**示例 2：**

> 输入：00000000000000000000000010000000
> 输出：1
解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。

**示例 3：**

> 输入：11111111111111111111111111111101
> 输出：31
解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。

**Answer**

*法一：JavaScript中的位运算符：“&”*

当对一对数位执行位运算 AND 时，如果数位均为 1 则返回 1。

|运算|结果|
|---|---|
|0 & 0|0|
|0 & 1|0|
|1 & 0|0|
|1 & 1|1|

**n &= (n – 1) 能清除最右边的1，同时累加计数器，直至n为0**

n相当于在n - 1的最低位加上1。
举个例子，8（1000）= 7（0111）+ 1（0001），所以8 & 7 = （1000）&（0111）= 0（0000），清除了8最右边的1（其实就是最高位的1，因为8的二进制中只有一个1）。
再比如7（0111）= 6（0110）+ 1（0001），所以7 & 6 = （0111）&（0110）= 6（0110），清除了7的二进制表示中最右边的1（也就是最低位的1）

**Answer**

```js
var hammingWeight = function(n) {
    let sum = 0;
    while (n) {
        n = n & (n - 1);
        sum++
    }
    return sum;
};

var n = 00000000000000000000000000001011;
console.log(hammingWeight(n))
```

# 198. 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

**示例 1:**

> 输入: [1,2,3,1]
> 输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

**示例 2:**

> 输入: [2,7,9,3,1]
> 输出: 12
解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。



1. 如果数组长度为1，那么直接返回数组唯一项。 
2. 如果数组长度为2，那么返回“第1项”和“第2项”的较大者。 
3. 如果数组长度为3，那么返回“数组长度为1的结果+第3项”与“数组长度为2的结果”的较大者。 
4. 如果数组长度为4，那么返回“数组长度为2的结果+第4项”与“数组长度为3的结果”的较大者。 
5. …… 
6. 如果数组长度为n，那么返回“数组长度为n-2的结果+第n项”与“数组长度为n-1的结果”的较大者。

**Answer**

*法一*

```js
var rob2 = function(nums) {
    const len = nums.length;
    if (len == 0) {
        return 0
    }
    let arr = new Array(len + 1);
    arr[0] = 0;
    arr[1] = nums[0];
    for(let i = 2; i <= len; i++) {
        arr[i] = Math.max(arr[i-1], arr[i-2] + nums[i-1])
    }
    return arr[len]
};
```

*法二*

```js
var rob = function(nums) {
    let result = 0;
    let max = 0;
    for(let i = 0; i < nums.length; i++) {
        let temp = result;
        result = max;
        max = Math.max(temp + nums[i], max);
    }
    return max
};
var nums = [2,7,9,3,1];
console.log(rob(nums));
```

# 202. 快乐数

编写一个算法来判断一个数是不是“快乐数”。

一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。

**示例: **

> 输入: 19
> 输出: true
解释: 
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1


**成功的例子(19)**

- 19 => 1 + 81
- 82 => 64 + 4
- 68 => 36 + 64
- 100 => 1 + 0 + 0

**失败的例子(20)**

- 20 => 4 + 0
- 4 => 16
- 16 => 1 + 36
- 37 => 9 + 49
- 58 => 25 + 64
- 89 => 64 + 81
- 145 => 1 + 16 + 25
- 42 => 16 + 4
- 20 可以看到, 20再次重复出现了, 所以永远不可能等于1

那思路就是将每次求的平方和存入数组，判断重复, 就return false

**Answer**

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isHappy = function(n) {
    var result = [];
    while(sum !== 1){
        var arr = n.toString().split('');
        var sum = 0;
        for (let i = 0; i < arr.length; i++) {
            sum += Math.pow(parseInt(arr[i]),2)
        }
        if (result.indexOf(sum) > -1) {
            return false
        }
        n = sum;
        result.push(sum); 
    }
    return true
};
var n = 20;
console.log(isHappy(n));
```


# 204. 计数质数

统计所有小于非负整数 n 的质数的数量。

**示例:**

> 输入: 10
> 输出: 4
解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。

**Answer**

*法一：直接循环判断每个数是否是质数*

缺点：超时

```js
/**
 * @param {number} n
 * @return {number}
 */
var countPrimes = function(n) {
    var count = 0;
    for (let i = 1; i < n; i++) {
        if (isPrime(i)) {
            count++
        }
    }
    // 判断是否是质数
    function isPrime(k) {
        if (k === 1) {
            return false
        }
        for(let i = 2; i < k; i++) {
            if (Number.isInteger(k/i)) {
                return false
            }
        } 
        return true   
    }
    return count; 
};
var n = 499979;
console.log(countPrimes(n));
```

*法二：厄拉多塞筛法*

每计算一个数，都要把它的倍数去掉。到了n，数一下留下了几个数。

```js
var countPrimes2 = function(n) {
    var count = 0;
    var arr = [];
    for (let i = 2; i < n; i++) {
        if (!arr[i]) {
            count++
            for (let j = 2 * i; j < n; j += i) {
                arr[j] = true
            }
        }
    }
    return count; 
};
```

```js
    // 判断一个数是否为质数
    var isPrime = function(n) {
        if (n == 2) return true;
        if (n < 2 || n % 2 == 0) return false;
        for (let i = 3; i <= Math.sqrt(n); i += 2) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }
```

# 205. 同构字符串

给定两个字符串 s 和 t，判断它们是否是同构的。

如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。

所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。

**示例 1:**

> 输入: s = "egg", t = "add"
> 输出: true

**示例 2:**

> 输入: s = "foo", t = "bar"
> 输出: false

**示例 3:**

> 输入: s = "paper", t = "title"
> 输出: true

**说明:**

你可以假设 s 和 t 具有相同的长度。

**Answer**

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isIsomorphic = function(s, t) {
    if (s === t) {
        return true
    }
    for (let i = 0; i < s.length; i++) {
        if (s.indexOf(s[i]) !== t.indexOf(t[i])) {
            return false
        }
    }
    return true
};
var s = "ab";
var t = "aa";
console.log(isIsomorphic(s, t));
```

# 217. 存在重复元素

给定一个整数数组，判断是否存在重复元素。

如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。

**示例 1:**

> 输入: [1,2,3,1]
> 输出: true

**示例 2:**

> 输入: [1,2,3,4]
> 输出: false

**示例 3:**

> 输入: [1,1,1,3,3,4,3,2,4,2]
> 输出: true

**Answer**

*法一：判断indexOf与lastIndexOf是否相等*

缺点：极慢，不推荐

```js
var containsDuplicate = function(nums) {
    let len = nums.length;
    for (let i = 0; i < len; i++) {
        if (nums.indexOf(nums[i]) !== nums.lastIndexOf(nums[i])) {
            return true
        }
    }
    return false
};
var nums = [3,3];
console.log(containsDuplicate(nums));

```

*法二：借用对象*

速度提升了不少，但消耗内存

```js
var containsDuplicate2 = function(nums) {
    let len = nums.length;
    let obj = {};
    for (let i = 0; i < len; i++) {
        if (!obj[nums[i]]) {
            obj[nums[i]] = true
        } else {
            return true
        }
    }
    return false
};
console.log(containsDuplicate2(nums));

```

*法三：new Set(arr)*

- ES6中set的元素的唯一的,如果重复只取其一

优点：执行用时少，占用内存小，推荐

```js

var containsDuplicate3 = function(nums) {
    return !(new Set(nums).size === nums.length)
};
console.log(containsDuplicate3(nums));

```

*法四：数组排序后比较相邻两项是否相等*

内存占用明显减少，但执行时间中等

```js
var containsDuplicate4 = function(nums) {
    nums.sort();
    let len = nums.length;
    for (let i = 0; i < len; i++) {
        if (nums[i] == nums[i+1]) {
            return true
        }
    }
    return false
};
console.log(containsDuplicate4(nums));
```

# 219. 存在重复元素 II

给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的绝对值最大为 k。

**示例 1:**

> 输入: nums = [1,2,3,1], k = 3
> 输出: true

**示例 2:**

> 输入: nums = [1,0,1,1], k = 1
> 输出: true

**示例 3:**

> 输入: nums = [1,2,3,1,2,3], k = 2
> 输出: false

**Answer**

*法一：对象存储元素和它出现的索引,然后循环判断多次出现的元素索引相减*

```js
var nums = [1,2,3,1,2,3];
var k = 2;

var obj = {
1: [0,3],
2: [1,4],
3: [2,5]
}
```
```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {boolean}
 */
var containsNearbyDuplicate = function(nums, k) {
    var obj = {};
    for (let i = 0; i < nums.length; i++) {
        if(!obj[nums[i]]) {
            obj[nums[i]] = [i];
        } else {
            obj[nums[i]].push(i)
        }
    }
    for (let key in obj) {
        if (obj[key].length > 1) {
            console.log(obj[key])
            for (let j = 0; j < obj[key].length-1; j++) {
                if (Math.abs(obj[key][j+1] - obj[key][j]) <= k) {
                    return true
                }
            }
        }
    }
    return false
};

var nums = [1,2,3,1,2,3];
var k = 2;
console.log(containsNearbyDuplicate(nums, k));
```

*法二:借助Map对象*

1. 遍历数组，如果当前值不存在map表里，把值->key,下标->value,存进map表
2. 如果当前值在map表里存在，看下两个值下标的绝对值是否 <= k
3. 如果 <= k，返回true
4. 否则，更新当前值的下标。因为之前的都不成功，如果有下一个相同元素的话绝对值会更大。
5. 循环完成还没有匹配成功，返回false

优点：改善了法一，可以一边存一遍比较，当然更快一些

```js
var nums = [1,2,3,1];

map = {1 => 3, 2 => 1, 3 => 2}
```

```js
var containsNearbyDuplicate = function(nums, k) {
    let map = new Map();
    for(let i = 0; i < nums.length; i++) {
        if(map.has(nums[i])) {
            if(Math.abs(map.get(nums[i]) - i) <= k) {
                return true
            } else {
                map.set(nums[i], i)
            }
        } else {
            map.set(nums[i], i)
        }
    }
    return false;
}
```

# 231. 2的幂

给定一个整数，编写一个函数来判断它是否是 2 的幂次方。

**示例 1:**

> 输入: 1
> 输出: true
解释: 20 = 1

**示例 2:**

> 输入: 16
> 输出: true
解释: 24 = 16

**示例 3:**

> 输入: 218
> 输出: false

**Answer**

*法一*

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfTwo = function(n) {
    while(n >= 2) {
        n /= 2
    }
    if (n === 1) {
        return true
    } else {
        return false
    }
};

var n = 0
console.log(isPowerOfTwo(n));
```

*法二*

```js
var isPowerOfTwo = function(n) {
    return Number.isInteger(Math.log2(n));
};
```


# 242. 有效的字母异位词

给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。

**示例 1:**

> 输入: s = "anagram", t = "nagaram"
> 输出: true

**示例 2:**

> 输入: s = "rat", t = "car"
> 输出: false

**Answer**

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if (s.length !== t.length) {
        return false
    };
    return s.split('').sort().join('') === t.split('').sort().join('')
};

var s = "anag";
var t = "naga";
console.log(isAnagram(s, t));
```


# 258. 各位相加

给定一个非负整数 num，反复将各个位上的数字相加，直到结果为一位数。

**示例:**

> 输入: 38
> 输出: 2 
解释: 各位相加的过程为：3 + 8 = 11, 1 + 1 = 2。 由于 2 是一位数，所以返回 2。

**进阶:**

你可以不使用循环或者递归，且在 O(1) 时间复杂度内解决这个问题吗？

**Answer**

*法一：while+while，每次取余数相加*

```js
/**
 * @param {number} num
 * @return {number}
 */
var addDigits = function(num) {
    while (num > 9) {
        var i = 0;
        var l = num.toString().length;
        // 被除数
        var divIdendX = num;
        // 余数
        var quotient;
        var sum = 0;
        while(i < l) {
            // 每次求的最右边位上的这个数
            quotient = divIdendX % 10;
            divIdendX = Math.floor(divIdendX / 10)
            i++
            sum += quotient
        } 
        num = sum
    }
    return num
};
var num = 19;
console.log(addDigits(num));

```

*法二：while+for，借用数组*

```js
var addDigits2 = function(num) {
    while (num > 9) {
        var str = num.toString();
        var sum = 0;
        for(let i = 0; i < str.length; i++) {
            sum += parseInt(str[i])
        }
        num = parseInt(sum)
    }
    return num
};
console.log(addDigits2(num));
```

*法三：一次for循环，加的时候超过10就减9*

```js
var addDigits3 = function(num) {
    var sum = 0;
    var str = num.toString();
    for(let i = 0; i < str.length; i++) {
        sum += (str[i]) * 1;
        if (sum >= 10) {
            sum -= 9
        } 
    }
    return sum
};
console.log(addDigits3(num));
```

*法四：借助数组的reduce方法*

```js
var addDigits4 = function(num) {
    while (num > 9) {
        num = num.toString().split('').reduce((a, b) => parseInt(a) + parseInt(b))
    }
    return num
};
console.log(addDigits4(num));
```

# 263. 丑数

编写一个程序判断给定的数是否为丑数。

丑数就是只包含质因数 2, 3, 5 的正整数。

**示例 1:**

> 输入: 6
> 输出: true
解释: 6 = 2 × 3

**示例 2:**

> 输入: 8
> 输出: true
解释: 8 = 2 × 2 × 2

**示例 3:**

> 输入: 14
> 输出: false 
解释: 14 不是丑数，因为它包含了另外一个质因数 7。

**说明：**

1 是丑数。
输入不会超过 32 位有符号整数的范围: [−231,  231 − 1]。

**Answer**

*法一*

```js
/**
 * @param {number} num
 * @return {boolean}
 */
var isUgly = function(num) {
    while(num > 1) {
        if (Number.isInteger(num/2)) {
            num /= 2;
        } else if (Number.isInteger(num/3)) {
            num /= 3
        } else if (Number.isInteger(num/5)) {
            num /= 5
        } else {
            return false
        }
    }
    return num === 1
};
var num = 6;
console.log(isUgly(num));
```

*法二：同法一*

```js
var isUgly2 = function(num) {
    if (num < 1) {
        return false
    }
    while (num % 2 === 0) {
        num /= 2;
    } 
    while (num % 3 === 0) {
        num /= 3
    } 
    while (num % 5 === 0) {
        num /= 5
    }
    return num === 1
};
console.log(isUgly2(num));
```

# 268. 缺失数字

给定一个包含 0, 1, 2, ..., n 中 n 个数的序列，找出 0 .. n 中没有出现在序列中的那个数。

**示例 1:**

> 输入: [3,0,1]
> 输出: 2

**示例 2:**

> 输入: [9,6,4,2,3,5,7,0,1]
> 输出: 8

**说明:**

你的算法应具有线性时间复杂度。你能否仅使用额外常数空间来实现?

**Answer**

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var missingNumber = function(nums) {
    nums.sort((a, b) => a - b);
    for (let i = 0; i < nums.length; i++) {
        if (i !== nums[i]) {
            return i
        }
    }
    return nums.length
};
var nums = [9,6,4,2,3,5,7,0,1];
console.log(missingNumber(nums));
```

# 283. 移动零

给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例:**

> 输入: [0,1,0,3,12]
> 输出: [1,3,12,0,0]

**说明:**

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

**Answer**

```js
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var moveZeroes = function(nums) {
    for(let i = nums.length - 1; i >= 0 ; i--) {
    	if (nums[i] === 0) {
    		nums.splice(i,1);
    		nums.push(0)
    	}
    }
    return nums
};
var nums = [0,1,0,3,12];
console.log(moveZeroes(nums));
```

# 290. 单词规律

给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。

这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。

**示例1:**

> 输入: pattern = "abba", str = "dog cat cat dog"
> 输出: true

**示例 2:**

> 输入:pattern = "abba", str = "dog cat cat fish"
> 输出: false

**示例 3:**

> 输入: pattern = "aaaa", str = "dog cat cat dog"
> 输出: false

**示例 4:**

> 输入: pattern = "abba", str = "dog dog dog dog"
> 输出: false

**说明:**

你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。

**Answer**

解题思路：对比objPat和objStr中单词出现的索引是否一样

```js
var pattern = "abba";
var str = "dog cat dog cat";

var objPat = {
'a': [0, 3],
'b': [1, 2]
};
var objStr = {
'dog': [1, 3],
'cat': [0, 2]
};
```

```js
var wordPattern = function(pattern, str) {
    var arr = str.split(' ');
    if (pattern.length !== arr.length) {
    	return false;
    }
    var objPat = {};
    var objStr = {};
    for (let j = 0; j < pattern.length; j++) {
        if (!objPat[pattern[j]]) {
        	objPat[pattern[j]] = [j]
        } else {
        	objPat[pattern[j]].push(j)
        }
    }
    for (let j = 0; j < arr.length; j++) {
        if (!objStr[arr[j]]) {
        	objStr[arr[j]] = [j]
        } else {
        	objStr[arr[j]].push(j)
        }
    }
    if (Object.keys(objPat).length !== Object.keys(objStr).length) {
    	return false;
    }
    for (let k = 0; k < Object.keys(objPat).length; k++) {
        for (let m = 0; m < objPat[Object.keys(objPat)[k]].length; m++) {
        	if (objPat[Object.keys(objPat)[k]][m] !== objStr[Object.keys(objStr)[k]][m]) {
        		return false
        	}
        }
        return true
    }
    return true;
};
```

# 292. Nim 游戏

你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。

你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。

**示例:**

> 输入: 4
> 输出: false 
解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；
     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。

**Answer**

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var canWinNim = function(n) {
    return n % 4 === 0 ? false : true
};
```

# 299. 猜数字游戏

你正在和你的朋友玩 猜数字（Bulls and Cows）游戏：你写下一个数字让你的朋友猜。每次他猜测后，你给他一个提示，告诉他有多少位数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位数字猜对了但是位置不对（称为“Cows”, 奶牛）。你的朋友将会根据提示继续猜，直到猜出秘密数字。

请写出一个根据秘密数字和朋友的猜测数返回提示的函数，用 A 表示公牛，用 B 表示奶牛。

请注意秘密数字和朋友的猜测数都可能含有重复数字。

**示例 1:**

> 输入: secret = "1807", guess = "7810"
> 输出: "1A3B"
解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。

**示例 2:**

> 输入: secret = "1123", guess = "0111"
> 输出: "1A1B"
解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。

说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。

**Answer**

```js
/**
 * @param {string} secret
 * @param {string} guess
 * @return {string}
 */
var getHint = function(secret, guess) {
	var bulls = 0;
	var cows = 0;
    for (let i = 0; i < secret.length; i++) {
        if (secret[i] === guess[i]) {
        	bulls++
        }
    }
    for (let i = 0; i < guess.length; i++) {
    	let index = secret.indexOf(guess[i])
        if (index !== -1) {
        	cows++;
        	secret = secret.substring(0, index) + secret.substring(index + 1, secret.length)
        }
    }
    return bulls + 'A' + (cows - bulls) + 'B';
};

var secret = "1123";
var guess = "0111";
console.log(getHint(secret, guess));
```

# 303. 区域和检索 - 数组不可变

给定一个整数数组  nums，求出数组从索引 i 到 j  (i ≤ j) 范围内元素的总和，包含 i,  j 两点。

**示例：**

给定 nums = [-2, 0, 3, -5, 2, -1]，求和函数为 sumRange()

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3

**说明:**

你可以假设数组不可变。
会多次调用 sumRange 方法。

**Answer**

```js
/**
 * @param {number[]} nums
 */
var NumArray = function(nums) {
    this.nums = nums;
};

/** 
 * @param {number} i 
 * @param {number} j
 * @return {number}
 */
NumArray.prototype.sumRange = function(i, j) {
    let sum = 0;
    for(let k  = i; k <= j; k++){
        sum += this.nums[k];
    }
    return sum;
};

/** 
 * Your NumArray object will be instantiated and called as such:
 * var obj = new NumArray(nums)
 * var param_1 = obj.sumRange(i,j)
 */
var nums = [-2, 0, 3, -5, 2, -1];
var i = 0;
var j = 2;
var obj = new NumArray(nums);
var param_1 = obj.sumRange(i,j)
console.log(param_1);
```

# 326. 3的幂

给定一个整数，写一个函数来判断它是否是 3 的幂次方。

**示例 1:**

> 输入: 27
> 输出: true

**示例 2:**

> 输入: 0
> 输出: false

**示例 3:**

> 输入: 9
> 输出: true

**示例 4:**

> 输入: 45
> 输出: false

**进阶：**

你能不使用循环或者递归来完成本题吗？

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var isPowerOfThree = function(n) {
    while(n >= 3) {
        n /= 3
    }
    if (n === 1) {
        return true
    } else {
        return false
    }  
};
var n = -3;
console.log(isPowerOfThree(n));
```

# 342. 4的幂

给定一个整数 (32 位有符号整数)，请编写一个函数来判断它是否是 4 的幂次方。

**示例 1:**

输入: 16
输出: true

**示例 2:**

输入: 5
输出: false

**进阶：**

你能不使用循环或者递归来完成本题吗？

**Answer**

*法一：将数字转换成二进制，再用正则去匹配*

规律：

|4的n次方|十进制|二进制|
|---|---|---|
|4^0|1|1|
|4^1|4|100|
|4^2|16|10000|
|4^3|64|1000000|
|4^4|256|100000000|
|4^n|...|/\^1(00)*$/|

```js
/**
 * @param {number} num
 * @return {boolean}
 */
var isPowerOfFour = function(num) {
    if (num < 0) {
       return false
    }
    return /^1(00)*$/.test(num.toString(2))
};
var num = 1;
console.log(isPowerOfFour(num));
```

法二：位运算& + 余数

n & (n - 1) 可以判断是否为2的幂

|2^m|n&(n-1)|二进制n&(n-1)|
|---|---|---|
|2^0 = 1|1&0|1 & 0 = 0|
|2^1 = 2|2&1|10 & 01 = 0|
|2^2 = 4|4&3|100 & 011 = 0|
|2^3 = 8|8&7|1000 & 0111 = 0|
|2^4 = 16|16&15|10000 & 01111 = 0|

```js
var isPowerOfFour2 = function(num) {
    if (num < 0 || num & (num - 1))//排除不是2的幂次的数
    {
        return false;
    }
    return num % 3 == 1;
};
```

# 344. 反转字符串【11/1】

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

**示例 1：**

> 输入：["h","e","l","l","o"]
> 输出：["o","l","l","e","h"]

**示例 2：**

> 输入：["H","a","n","n","a","h"]
> 输出：["h","a","n","n","a","H"]

**Answer**

```js
/**
 * @param {character[]} s
 * @return {void} Do not return anything, modify s in-place instead.
 */
var reverseString = function(s) {
    var length = s.length;
    var middle = Math.floor(s.length/2)
    for (let i = 0; i < middle; i++) {
        var temp = s[i];
        s[i] = s[length-i-1];
        s[length-i-1] = temp;
    }
    return s
};

var s = ["h","e","l","l","o"];
console.log(reverseString(s));
```

# 345. 反转字符串中的元音字母

编写一个函数，以字符串作为输入，反转该字符串中的元音字母。

**示例 1:**

> 输入: "hello"
> 输出: "holle"

**示例 2:**

> 输入: "leetcode"
> 输出: "leotcede"

**说明:**

元音字母不包含字母"y"。

**Answer**

典型的双指针应用

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseVowels = function(s) {
    var vowels = "aeiouAEIOU";
    var sArr = s.split('');
    var i = 0;
    var j = s.length - 1;
    while(i < j) {
        if (vowels.indexOf(sArr[i]) === -1 && vowels.indexOf(sArr[j]) !== -1) {
            i++;
        } else if (vowels.indexOf(sArr[i]) !== -1 && vowels.indexOf(sArr[j]) === -1) {
            j--;
        } else if (vowels.indexOf(sArr[i]) === -1 && vowels.indexOf(sArr[j]) === -1) {
            i++;
            j--;
        } else {
            [sArr[i],sArr[j]] = [sArr[j],sArr[i]];
            i++;
            j--;
        }
    }
    return sArr.join('');
};

var s = "leetcode";
console.log(reverseVowels(s));
```

# 349. 两个数组的交集

给定两个数组，编写一个函数来计算它们的交集。

**示例 1:**

> 输入: nums1 = [1,2,2,1], nums2 = [2,2]
> 输出: [2]

**示例 2:**

> 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出: [9,4]

**说明:**

输出结果中的每个元素一定是唯一的。
我们可以不考虑输出结果的顺序。

**Answer**

借助map对象

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersection = function(nums1, nums2) {
    var result = [];
    var map = new Map();
    for (let i = 0; i < nums1.length; i++) {
        if (nums2.indexOf(nums1[i]) !== -1) {
            map.set(nums1[i], true)
        }
    }
    map.forEach( (item, index) => {
        result.push(index)
    })
    return result;
};

var nums1 = [4, 9, 5];
var nums2 = [9, 4, 9, 8, 4];
console.log(intersection(nums1, nums2));
```

# 350. 两个数组的交集 II

给定两个数组，编写一个函数来计算它们的交集。

**示例 1:**

> 输入: nums1 = [1,2,2,1], nums2 = [2,2]
> 输出: [2,2]

**示例 2:**

> 输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
> 输出: [4,9]

**说明：**

- 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
- 我们可以不考虑输出结果的顺序。

**进阶:**

如果给定的数组已经排好序呢？你将如何优化你的算法？
如果 nums1 的大小比 nums2 小很多，哪种方法更优？
如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？

**Answer**

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var intersect = function(nums1, nums2) {
    var result = [];
    for (let i = 0; i < nums1.length; i++) {
        var index = nums2.indexOf(nums1[i]);
        if (index !== -1) {
            result.push(nums1[i]);
            nums2.splice(index, 1)
        }
    }
    return result;
};
```

```js
var intersect2 = function(nums1, nums2) {
    var result = [];
    var map = new Map();
    for (let i = 0; i < nums1.length; i++) {
        var index = nums2.indexOf(nums1[i]);
        if (index !== -1) {
            if (!map.has(nums1[i])) {
                map.set(nums1[i], 1);
            } else {
                var value = map.get(nums1[i]);
                map.set(nums1[i], ++value);  
            } 
            nums2.splice(index, 1)
        }
    }
    map.forEach( (item, index) => {
        for (let i = 0; i < item; i++) {
            result.push(index)
        }
    })
    return result;
};
var nums1 = [1, 2, 2, 1];
var nums2 = [2, 2];
console.log(intersect(nums1, nums2));
```

# 367. 有效的完全平方数

给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。

说明：不要使用任何内置的库函数，如  sqrt。

**示例 1：**

> 输入：16
> 输出：True

**示例 2：**

> 输入：14
> 输出：False

**Answer**

*法一：暴力递增判断*

```js
/**
 * @param {number} num
 * @return {boolean}
 */
var isPerfectSquare = function(num) {
    var i = 1;
    while(i * i <= num) {
        if (i * i < num) {
            i++;
        } else if (i * i === num) {
            return true
        }
    }
    return false
};

var num = 16;
console.log(isPerfectSquare(num));
```

*法二： 二分查找*

```js
var isPerfectSquare2 = function(num) {
    let left = 1;
    let right = num;
    while (left <= right) {
        let mid = parseInt((left+right)/2);
        let product = mid * mid;
        if (product === num) {
            return true;
        } else if (product > num) {
            right = mid - 1;
        } else {
            left = mid + 1
        }
    }
    return false;
};
```

# 371. 两整数之和

不使用运算符 + 和 - ​​​​​​​，计算两整数 ​​​​​​​a 、b ​​​​​​​之和。

**示例 1:**

> 输入: a = 1, b = 2
> 输出: 3

**示例 2:**

> 输入: a = -2, b = 3
> 输出: 1

**Answer**

```js
/**
 * @param {number} a
 * @param {number} b
 * @return {number}
 */
var getSum = function(a, b) {
    if (a === 0 && b === 0) {
        return 0;
    }
    if (a === 0) {
        return b;
    }
    if (b === 0) {
        return a;
    }
    if (a > 0) {
        while (a > 0) {
            a--;
            b++;
        }
        return b;
    } else {
        while (a < 0) {
            a++;
            b--;
        }
        return b;
    }
};

var a = 3;
var b = 2;
console.log(getSum(a, b));
```

# 383. 赎金信

给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串ransom能不能由第二个字符串magazines里面的字符构成。如果可以构成，返回 true ；否则返回 false。

(题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。)

**注意：**

你可以假设两个字符串均只含有小写字母。

> canConstruct("a", "b") -> false
> canConstruct("aa", "ab") -> false
> canConstruct("aa", "aab") -> true

**Answer**

```js
/**
 * @param {string} ransomNote
 * @param {string} magazine
 * @return {boolean}
 */
var canConstruct = function(ransomNote, magazine) {
    for (let i = 0; i < ransomNote.length; i++) {
        let index = magazine.indexOf(ransomNote[i])
        if (index === -1) {
            return false
        } else {
            magazine = magazine.substring(0, index) + magazine.substring(index + 1, magazine.length)

        }
    }
    return true
};

var ransomNote = 'aa';
var magazine = 'aab';
console.log(canConstruct(ransomNote, magazine));
```

# 387. 字符串中的第一个唯一字符

给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。

**案例:**

> s = "leetcode"
> 返回 0.

> s = "loveleetcode",
> 返回 2.
 
注意事项：您可以假定该字符串只包含小写字母。

**Answer**

```js
/**
 * @param {string} s
 * @return {number}
 */
var firstUniqChar = function(s) {
    let map = new Map();
    for (let i = 0; i < s.length; i++) {
        if (!map.has(s[i])) {
            map.set(s[i], 1)
        } else {
            let val = map.get(s[i])
            map.set(s[i], ++val)
        }
    }
    for (let key of map) {
        if (key[1] === 1) {
            return s.indexOf(key[0])
        }
    }
    return -1
};
var s = "loveleetcode";
console.log(firstUniqChar(s));
```

```js
var firstUniqChar2 = function(s) {
    let map = new Map();
    for (let i = 0; i < s.length; i++) {
        if (s.indexOf(s[i]) === s.lastIndexOf(s[i])) {
            return i
        }
    }
    return -1
};
console.log(firstUniqChar2(s));
```

# 389. 找不同

给定两个字符串 s 和 t，它们只包含小写字母。

字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。

请找出在 t 中被添加的字母。

**示例:**

> 输入：
s = "abcd"
t = "abcde"

> 输出：
e

**解释：**
'e' 是那个被添加的字母。

**Answer**

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {character}
 */
var findTheDifference = function(s, t) {
    for (let i = 0; i < s.length; i++) {
        let index = t.indexOf(s[i])
        if (index !== -1) {
            //t = t.substring(0, index) + t.substring(index + 1, t.length)
            t = t.replace(s[i], '')
        }
    }
    return t
};
var s = "aa";
var t = "aaa";
console.log(findTheDifference(s, t));
```

```js
var findTheDifference2 = function(s, t) {
    let map = new Map();
    for ( let i = 0; i < s.length; i++) {
        let val = map.get(s[i]);
        map.set(s[i], val === undefined ? 1 : val + 1);
    }
    for ( let i = 0; i < t.length; i++) {
        let val = map.get(t[i])
        if (val === 0 || val === undefined) {
            return t[i]
        } else {
            map.set(t[i], val - 1)
        }
    }
};
console.log(findTheDifference2(s, t));
```

# 392. 判断子序列

给定字符串 s 和 t ，判断 s 是否为 t 的子序列。

你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ~= 500,000），而 s 是个短字符串（长度 <=100）。

字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"aec"不是）。

**示例 1:**

> s = "abc", t = "ahbgdc"

> 返回 true.

**示例 2:**

> s = "axc", t = "ahbgdc"

> 返回 false.

后续挑战 :

如果有大量输入的 S，称作S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？

**Answer**

*法一： 正则匹配*

缺点：当太大，会超时，故不可取

```js
/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isSubsequence = function(s, t) {
    let str = '[a-z]*';
    for (let i = 0; i < s.length; i++) {
        str += s[i] + '[a-z]*'
    }
    let pat = new RegExp(str);
    return pat.test(t)
};
var s = "axc";
var t = "ahbgdc";
console.log(isSubsequence(s, t));
```

*法二： 贪心-字符串指针*

推荐

```js
/**贪心-字符串指针**/
var isSubsequence2 = function(s, t) {
    if (s.length === 0) {
        return true;
    }
    let sPos = 0;
    let tPos = 0;
    let sLen = s.length;
    let tLen = t.length;
    while (tPos < tLen) {
        if (s[sPos] === t[tPos]) {
            sPos++
        }
        if (sPos === sLen) {
            return true
        }
        tPos++
    }
    return false;
};
console.log(isSubsequence2(s, t));
```

*法三：贪心-字符串转数组*

```js
var isSubsequence = function(s, t) {
    if(s.length == 0) return true;
    let sStack = s.split('');
    let tStack = t.split('');
    while(tStack.length>0){
            let tItem = tStack.pop();
            if(tItem == sStack[sStack.length-1]){
                sStack.pop();
                if(sStack.length == 0) return true;
            }
    }
    return false;
};
```

# 409. 最长回文串

给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。

在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。

**注意:**
假设字符串的长度不会超过 1010。

**示例 1:**

> 输入:
"abccccdd"

> 输出:
7

**解释:**
我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。

**Answer**

```js
/**
 * @param {string} s
 * @return {number}
 */
var longestPalindrome = function(s) {
    let map = new Map();
    let num = 0;
    let single = false;
    for (let i = 0; i < s.length; i++) {
        let val = map.get(s[i]);
        if (!val) {
            map.set(s[i], 1)
        } else {
            map.set(s[i], val + 1)
        }
    }
    map.forEach( (item, index) => {
        if (item % 2 === 0) {
            num += item
        } else {
            single = true;
            if (item > 1) {
                num += item - 1;
            }
        }
    })
    if (single) {
        num += 1;
    }
    return num;
};
var s = "aabbbb";
console.log(longestPalindrome(s));
```

# 412. Fizz Buzz

写一个程序，输出从 1 到 n 数字的字符串表示。

1. 如果 n 是3的倍数，输出“Fizz”；

2. 如果 n 是5的倍数，输出“Buzz”；

3. 如果 n 同时是3和5的倍数，输出 “FizzBuzz”。

**示例：**

> n = 15,

> 返回:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]

**Answer**

```js
/**
 * @param {number} n
 * @return {string[]}
 */
var fizzBuzz = function(n) {
    var arr = [];
    for (let i = 1; i <= n; i++) {
        if (i % 3 === 0 && i % 5 === 0) {
            arr.push('FizzBuzz')
        } else if (i % 3 === 0) {
            arr.push('Fizz')
        } else if (i % 5 === 0) {
            arr.push('Buzz')
        } else {
            arr.push(i.toString())
        }
    }
    return arr;
};

var n = 15;
console.log(fizzBuzz(n));
```

# 414. 第三大的数

给定一个非空数组，返回此数组中第三大的数。如果不存在，则返回数组中最大的数。要求算法时间复杂度必须是O(n)。

**示例 1:**

> 输入: [3, 2, 1]

> 输出: 1

解释: 第三大的数是 1.

**示例 2:**

> 输入: [1, 2]

> 输出: 2

解释: 第三大的数不存在, 所以返回最大的数 2 .

**示例 3:**

> 输入: [2, 2, 3, 1]

> 输出: 1

解释: 注意，要求返回第三大的数，是指第三大且唯一出现的数。
存在两个值为2的数，它们都排第二。

**Answer**

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var thirdMax = function(nums) {
    nums.sort((a, b) => b - a);
    let unique = [...new Set(nums)]
    return unique[2] === undefined ? unique[0] : unique[2]
};
var nums = [3,3,4,3,4,3,0,3,3];
console.log(thirdMax(nums));
```

# 434. 字符串中的单词数

统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。

请注意，你可以假定字符串里不包括任何不可打印的字符。

**示例:**

> 输入: "Hello, my name is John"
> 输出: 5

**Answer**

*法一： trim()+split()*
```js
/**
 * @param {string} s
 * @return {number}
 */
var countSegments = function(s) {
    s = s.trim();
    if (s === '') return 0
    return s.split(/\s+/).length
};
var s = " ";
console.log(countSegments(s));
```

*法二：遍历*

```js
var countSegments = function(s) {
    let count = 0;
    s += ' ';
    for (let p = 1; p < s.length; p++){
        if (s[p - 1] !== s[p] && s[p] === ' ') count++;
    }
    return count;
};
```

# 441. 排列硬币

你总共有 n 枚硬币，你需要将它们摆成一个阶梯形状，第 k 行就必须正好有 k 枚硬币。

给定一个数字 n，找出可形成完整阶梯行的总行数。

n 是一个非负整数，并且在32位有符号整型的范围内。

**示例 1:**

> n = 5

> 硬币可排列成以下几行:
¤
¤ ¤
¤ ¤

因为第三行不完整，所以返回2.

**示例 2:**

> n = 8

> 硬币可排列成以下几行:
¤
¤ ¤
¤ ¤ ¤
¤ ¤

因为第四行不完整，所以返回3.

**Answer**

*法一：*

```js
/**
 * @param {number} n
 * @return {number}
 */
var arrangeCoins = function(n) {
    let arr = [0];
    let i = 1;
    while(arr[arr.length-1] < n) {
        arr.push(arr[arr.length-1]+i)
        i++
    }
    return arr[arr.length-1] === n ? arr.length-1 : arr.length - 2
};
var n = 6;
console.log(arrangeCoins(n));
```

*法二*

思路： 

用硬币数不断减去当前行，得到剩余硬币数，只有当剩余硬币数大于当前行时，说明他还能排满下一行，则行数+1， 不满足的时候说明剩余硬币不够排满下一行了

```js
var arrangeCoins = function(n) {
    var line = 0 // 当前排满硬币的行
    while(n > line) {
        line++;
        n = n - line;
    }
    return line
};
```

## 43. 压缩字符串

给定一组字符，使用原地算法将其压缩。

压缩后的长度必须始终小于或等于原数组长度。

数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。

在完成原地修改输入数组后，返回数组的新长度。

**进阶：**

你能否仅使用O(1) 空间解决问题？

**示例 1：**

> 输入：
["a","a","b","b","c","c","c"]

> 输出：
返回6，输入数组的前6个字符应该是：["a","2","b","2","c","3"]

**说明：**
"aa"被"a2"替代。"bb"被"b2"替代。"ccc"被"c3"替代。

**示例 2：**

> 输入：
["a"]

> 输出：
返回1，输入数组的前1个字符应该是：["a"]

**说明：**
没有任何字符串被替代。

**示例 3：**

> 输入：
["a","b","b","b","b","b","b","b","b","b","b","b","b"]

> 输出：
返回4，输入数组的前4个字符应该是：["a","b","1","2"]。

**说明：**

由于字符"a"不重复，所以不会被压缩。"bbbbbbbbbbbb"被“b12”替代。
注意每个数字在数组中都有它自己的位置。

**注意：**

所有字符都有一个ASCII值在[35, 126]区间内。
1 <= len(chars) <= 1000。

**Answer**

```js
/**
 * @param {character[]} chars
 * @return {number}
 */
var compress = function(chars) {
    if(!chars.length) return 0;
    if(chars.length === 1) return 1;
    let ans = '';
    let l = 0;
    let r = 0;
    while(r < chars.length){
        if(chars[l] === chars[r]){
            if(r === chars.length - 1){
                let s = (r - l + 1) > 1 ? (r - l + 1) : '';
                ans += chars[l] + s;
                break;
            }else{
                r++;
                continue;
            }
        }
        // 下面都是不相同的
        if (r - l >= 2){ // 超过两个
            ans += chars[l] + (r - l);
            l = r;
        }else{ // 只有一个
            ans += chars[l];
            l = r;
        }
    }
    let arr = ans.split('')
    for(let i = 0; i < arr.length; i++){
        chars[i] = arr[i]
    }
    return arr.length
};

var chars = ["a","a","b","b","c","c","c"];
console.log(compress(chars));
```

# 448. 找到所有数组中消失的数字

给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。

找到所有在 [1, n] 范围之间没有出现在数组中的数字。

您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。

**示例:**

> 输入:
[4,3,2,7,8,2,3,1]

> 输出:
[5,6]

**Answer**

*法一*

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var findDisappearedNumbers = function(nums) {
    var n = nums.length;
    var res = [];
    for (let i = 1; i <= n; i++) {
        if (nums.indexOf(i) === -1) {
            res.push(i)
        }
    }
    return res
};
var nums = [4,3,2,7,8,2,3,1];
console.log(findDisappearedNumbers(nums));
```

*法二*

将所有正数作为数组下标，置对应数组值为负值。那么，仍为正数的位置即为（未出现过）消失的数字。
举个例子：

•	原始数组：[4,3,2,7,8,2,3,1] 
•	重置后为：[-4,-3,-2,-7,8,2,-3,-1] 
结论：[8,2] 分别对应的index为[5,6]（消失的数字）

**变换过程：**

|index|num|abs(num)-1|[4,3,2,7,8,2,3,1] 初始数据|   
|---|---|---|---|
| 0  |  4| 3 |[4,3,2,**-7**,8,2,3,1] 
| 1  |  3|2 |[4,3,**-2**,-7,8,2,3,1]
| 2  |  -2| 1 |[4,**-3**,-2,-7,8,2,3,1]
| 3  |  -7| 6 |[4,-3,-2,-7,8,2,**-3**,1]
| 4  |  8| 7 |[4,-3,-2,-7,8,2,-3,**-1**]
| 5  |  2| 1 |[4,**-3**,-2,-7,8,2,-3,-1]
| 6  |  -3 |2 |[4,-3,**-2**,-7,8,2,-3,-1]
| 7  |  -1| 0 |[**-4**,-3,-2,-7,8,2,-3,-1]


```js
var findDisappearedNumbers2 = function(nums) {
    var len = nums.length;
    var arr = [];
    for (let i = 0; i < len; i++) {
        nums[Math.abs(nums[i])-1] = -Math.abs(nums[Math.abs(nums[i])-1]);
    }
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] > 0) {
          arr.push(i + 1);
        }
    }
    return arr
};
```

# 455. 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。对每个孩子 i ，都有一个胃口值 gi ，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j ，都有一个尺寸 sj 。如果 sj >= gi ，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

注意：

你可以假设胃口值为正。
一个小朋友最多只能拥有一块饼干。

**示例 1:**

> 输入: [1,2,3], [1,1]

> 输出: 1

解释: 

你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
所以你应该输出1。

**示例 2:**

> 输入: [1,2], [1,2,3]

> 输出: 2

解释: 

你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
你拥有的饼干数量和尺寸都足以让所有孩子满足。
所以你应该输出2.

**Answer**

*法一：双指针*

```js
/**
 * @param {number[]} g
 * @param {number[]} s
 * @return {number}
 */
var findContentChildren = function(g, s) {
    g.sort((a, b) => a - b);
    s.sort((a, b) => a - b);
    let g_i = 0;
    let s_i = 0;
    let count = 0;
    while(g_i < g.length && s_i < s.length) {
        if (g[g_i] <= s[s_i]) {
            g_i++;
            s_i++;
            count += 1
        } else if (g[g_i] > s[s_i]) {
            s_i++;
        }
    }
    return count;
};
var g = [1,2,3];
var s = [1,1];
console.log(findContentChildren(g, s));
```

*法二：贪心算法*

```js
var findContentChildren2 = function(g, s) {
    let res = 0;

    s = s.sort((a, b) => a - b);

    g.sort((a, b) => a - b).forEach(item => {
        while (s.length) {
            if (item <= s.shift()) {
                res++;
                break;
            }
        }
    });

    return res;
};
console.log(findContentChildren2(g, s));
```

# 459. 重复的子字符串

给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

**示例 1:**

> 输入: "abab"

> 输出: True

解释: 可由子字符串 "ab" 重复两次构成。

**示例 2:**

> 输入: "aba"

> 输出: False

**示例 3:**

> 输入: "abcabcabcabc"

> 输出: True

解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。)

**Answer**

*法一：借用字符串*

1. 将原字符串给出拷贝一遍组成新字符串；
2. 掐头去尾留中间；
3. 如果还包含原字符串，则满足题意。

**举例:**

- s = abc|abc; // 2abc
- s+s = abc|abc|abc|abc; // 4abc
- s1 = a|bcabcabcab|c = bcabcabcab; // bc + 2*abc + ab

s1中依然包含s,则s是重复的字符串

```js
var repeatedSubstringPattern = function(s) {
    let s1 = (s + s).slice(1, -1);
    return s1.indexOf(s) != -1;
};
```

*法二：周期串*

周期串为s, 那么设定t表示最小周期, 数学中周期的表达式是

\begin{aligned} f(x+t)=f(x) \end{aligned}

字符串中 ​s = item * count
​
那么我们需要找到最小周期 t = item.length

```js
var repeatedSubstringPattern2 = function(s) {
    let len = s.length;
    for (let t = 1; t <= len / 2; t++) {
        const item = s.slice(0, t);
        const count = len / item.count;
        if (Number.isInteger(count) && item.repeat(count) === s) {
            return true
        }
    }
    return false
};
```

或者

```js
var repeatedSubstringPattern2 = function(s) {
    let len = s.length;
    let i = 1;
    while(i <= len / 2) {
        if (len % i == 0 && s.slice(0, i).repeat(len/i) == s) {
            return true
        }
        i++;
    }
    return false
};
```

*法三:正则匹配*

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var repeatedSubstringPattern = function(s) {
    let reg = /^(\w+)\1+$/
    return reg.test(s)
};
var s = "abab";
console.log(repeatedSubstringPattern(s));
```

`\1` 等于 `()` 中匹配的内容。

# 461. 汉明距离

两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。

给出两个整数 x 和 y，计算它们之间的汉明距离。

注意：

0 ≤ x, y < 2^31.

**示例:**

> 输入: x = 1, y = 4

> 输出: 2

解释:

```js
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑
```
上面的箭头指出了对应二进制位不同的位置。


**Answer**

*法一：二进制异或运算*

`^`：（`x^y`）两二进制上下比较只有位不相等时才取1，否则取零

```js
/**
 * @param {number} x
 * @param {number} y
 * @return {number}
 */
var hammingDistance = function(x, y) {
    let k = x^y;
    let str = k.toString(2);
    let count = 0;
    for (let i = 0; i < str.length; i++) {
        if (str[i] == 1) {
            count++
        }
    }
    return count
};
var x = 1;
var y = 4;
console.log(hammingDistance(x, y));
```

*法二*

```js
var hammingDistance = function(x, y) {
    let max = x >= y ? x : y;
    let max2 = max.toString(2);
    let x2 = x.toString(2).padStart(max2.length, '0');
    let y2 = y.toString(2).padStart(max2.length, '0');
    let count = 0;
    for (let i = 0; i < max2.length; i++) {
        if (x2[i] !== y2[i]) {
            count++
        }
    }
    return count
};
```

# 463. 岛屿的周长

给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。

网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。

岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。

**示例 :**

> 输入:
[[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]]

> 输出: 16

解释: 它的周长是下面图片中的 16 个黄色的边：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/island.png)

**Answer**

**思路:**

数学推理：`周长=个数*4-重合边*2`； 计算个数和重合边。

遍历遇到陆地的时候，【x>0&&y>0时】顺便查看它前面和上面是否也是陆地，是的话边长需要-2

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var islandPerimeter = function(grid) {
    let count = 0;
    for (let i = 0; i < grid.length; i++) {
        for(let j = 0; j < grid[i].length; j++) {
            if (grid[i][j] === 1) {
                count += 4;
                // 上面
                if (i > 0 && grid[i-1][j] == 1) {
                    count -= 2
                }
                // 前面
                if (j > 0 && grid[i][j-1] == 1) {
                    count -= 2;
                }
            }
        }
    }
    return count;
};

var grid = [[0,1,0,0],
 [1,1,1,0],
 [0,1,0,0],
 [1,1,0,0]];
console.log(islandPerimeter(grid));
```

# 475. 供暖器

冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。

现在，给出位于一条水平线上的房屋和供暖器的位置，找到可以覆盖所有房屋的最小加热半径。

所以，你的输入将会是房屋和供暖器的位置。你将输出供暖器的最小加热半径。

**说明:**

1. 给出的房屋和供暖器的数目是非负数且不会超过 25000。
2. 给出的房屋和供暖器的位置均是非负数且不会超过10^9。
3. 只要房屋位于供暖器的半径内(包括在边缘上)，它就可以得到供暖。
4. 所有供暖器都遵循你的半径标准，加热的半径也一样。

**示例 1:**

> 输入: [1,2,3],[2]
> 输出: 1
解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。

**示例 2:**

> 输入: [1,2,3,4],[1,4]
> 输出: 1
解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。

**Answer**

**理解题意：**

1.	对于每个房屋，要么用前面的暖气，要么用后面的，二者取近的，得到距离；
2.	对于所有的房屋，选择最大的上述距离。

*法一：暴力双循环*

```js
/**
 * @param {number[]} houses
 * @param {number[]} heaters
 * @return {number}
 */
var findRadius = function(houses, heaters) {
    houses.sort((a, b) => a - b);
    heaters.sort((a, b) => a - b);
    let count = 0;
    let nums = [];
    for (let i = 0; i < houses.length; i++) {
        count = Math.abs(houses[i]-heaters[0]);
        for(let j = 0; j < heaters.length; j++) {
            if (Math.abs(houses[i]-heaters[j]) > count) {
                break;
            }
            if (Math.abs(houses[i]-heaters[j]) < count) {
                count = Math.abs(houses[i]-heaters[j]);
            }
        }
        nums[i] = count;
    }
    nums.sort((a, b) => a - b);
    return nums[nums.length-1]
};
var houses =[1,2,3,4];
var heaters = [1,4];
console.log(findRadius(houses, heaters));
```

*法二：双指针*

```js
var findRadius2 = function(houses, heaters) {
    houses.sort((a, b) => a - b);
    heaters.sort((a, b) => a - b);
    let res = 0;
    let i = 0; // 房子指针
    let j = 0; // 暖气指针
    let r = 0; // 半径
    while(i < houses.length && j < heaters.length) {
        // 房子用右边的暖气
        if (houses[i] <= heaters[j]) {
            r = heaters[j] - houses[i];
            i += 1;
        // 房子左右两边的暖气都可用的时候，用距离小的那边的
        } else if (j < heaters.length - 1) {
            r = Math.min(heaters[j+1] - houses[i], houses[i] - heaters[j]);
            if (houses[i] < heaters[j+1]) {
                i += 1;
            } else {
                j += 1;
            }
        // 暖气指针指到最后一位时，房子只能用左边的暖气
        } else {
            r = houses[i] - heaters[j];
            i += 1
        }
        res = Math.max(res, r)
    }
    return res;
};
```

# 476. 数字的补数

给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

注意:

给定的整数保证在32位带符号整数的范围内。
你可以假定二进制数不包含前导零位。

**示例 1:**

> 输入: 5
> 输出: 2
解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。

**示例 2:**

> 输入: 1
> 输出: 0
解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。

**Answer**

```js
/**
 * @param {number} num
 * @return {number}
 */
var findComplement = function(num) {
    let num2 = num.toString(2);
    let res = '';
    for(let i = 0; i < num2.length; i++) {
        if (num2[i] == 0) {
            res += '1'
        } else {
            res += '0'
        }
    }
    return parseInt(res, 2)
};
var num = 1;
console.log(findComplement(num));
```

# 482. 密钥格式化

给定一个密钥字符串S，只包含字母，数字以及 '-'（破折号）。N 个 '-' 将字符串分成了 N+1 组。给定一个数字 K，重新格式化字符串，除了第一个分组以外，每个分组要包含 K 个字符，第一个分组至少要包含 1 个字符。两个分组之间用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。

给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。

**示例 1：**

> 输入：S = "5F3Z-2e-9-w", K = 4

> 输出："5F3Z-2E9W"

解释：字符串 S 被分成了两个部分，每部分 4 个字符；
     注意，两个额外的破折号需要删掉。

**示例 2：**

> 输入：S = "2-5g-3-J", K = 2

> 输出："2-5G-3J"

解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。
 

提示:

1. S 的长度不超过 12,000，K 为正整数
2. S 只包含字母数字（a-z，A-Z，0-9）以及破折号'-'
3. S 非空

**Answer**

*法一*

```js
/**
 * @param {string} S
 * @param {number} K
 * @return {string}
 */
var licenseKeyFormatting = function(S, K) {
    S = S.toUpperCase().replace(/\-/g,'');
    let index = S.length % K;
    let s1 = S.slice(0,index);
    let s2 = S.slice(index);
    let count = s2.length/K;
    var arr = [];
    for(let i = 0; i < count; i++) {
        arr.push(s2.substr(i*K, K))
    }
    if (s1 !== '') {
        arr.unshift(s1)
    }
    return arr.join('-');
};
var S = "5F3Z-2e-9-w";
var K = 4;
console.log(licenseKeyFormatting(S, K));
```

*法二：逆序插入*

```js
var licenseKeyFormatting2 = function(S, K) {
    S = S.replace(/-/g, '')
    let res = ''
    let i = S.length - K
    while (i + K > 0) {
        res = (i > 0 ? '-' : '') + S.substring(i, i + K) + res
        i -= K
    }
    return res.toUpperCase()
};
```

# 485. 最大连续1的个数

给定一个二进制数组， 计算其中最大连续1的个数。

**示例 1:**

> 输入: [1,1,0,1,1,1]
> 输出: 3
解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.

**注意：**

输入的数组只包含 0 和1。
输入数组的长度是正整数，且不超过 10,000。

**Answer**

*法一*

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findMaxConsecutiveOnes = function(nums) {
    let arr = nums.join('').split('0');
    let max = 0;
    arr.forEach((item) => {
        if(item.length > max) {
            max = item.length
        }
    })
    return max;
};
var nums = [1,1,0,1,1,1];
console.log(findMaxConsecutiveOnes(nums));
```

*法二：一遍遍历一遍比较*

```js
var findMaxConsecutiveOnes2 = function(nums) {
    let max = 0;
    let count = 0;
    for(let i = 0; i < nums.length; i++) {
        if (nums[i] == 1) {
            count++;
        } else {
            max = Math.max(max, count)
            count = 0;
        }
    }
    max = Math.max(max, count)
    return max
};
```

# 492. 构造矩形

作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的矩形的页面。要求：

1. 你设计的矩形页面必须等于给定的目标面积。

2. 宽度 W 不应大于长度 L，换言之，要求 L >= W 。

3. 长度 L 和宽度 W 之间的差距应当尽可能小。
你需要按顺序输出你设计的页面的长度 L 和宽度 W。

**示例：**

> 输入: 4
> 输出: [2, 2]
解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。
但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。
说明:

给定的面积不大于 10,000,000 且为正整数。
你设计的页面的长度和宽度必须都是正整数。

**Answer**

```js
/**
 * @param {number} area
 * @return {number[]}
 */
var constructRectangle = function(area) {
    let middle = parseInt(Math.sqrt(area));
    let arr = [];
    while(area % middle !== 0) {
        middle++
    }
    arr.push(middle);
    arr.push(area/middle);
    return arr.sort((a, b) => b - a);
};
var area = 30;
console.log(constructRectangle(area));
```

# 496. 下一个更大元素 I

给定两个没有重复元素的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。

nums1 中数字 x 的下一个更大元素是指 x 在 nums2 中对应位置的右边的第一个比 x 大的元素。如果不存在，对应位置输出-1。

**示例 1:**

> 输入: nums1 = [4,1,2], nums2 = [1,3,4,2].
> 输出: [-1,3,-1]
解释:
    对于num1中的数字4，你无法在第二个数组中找到下一个更大的数字，因此输出 -1。
    对于num1中的数字1，第二个数组中数字1右边的下一个较大数字是 3。
    对于num1中的数字2，第二个数组中没有下一个更大的数字，因此输出 -1。

**示例 2:**

> 输入: nums1 = [2,4], nums2 = [1,2,3,4].
> 输出: [3,-1]
解释:
    对于num1中的数字2，第二个数组中的下一个较大数字是3。
    对于num1中的数字4，第二个数组中没有下一个更大的数字，因此输出 -1。
注意:

nums1和nums2中所有元素是唯一的。
nums1和nums2 的数组大小都不超过1000。

**Answer**

暴力双循环

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @return {number[]}
 */
var nextGreaterElement = function(nums1, nums2) {
    let arr = [];
    for (let i = 0; i < nums1.length; i++) {
        let start = nums2.indexOf(nums1[i]) + 1;
        let isFind = false;
        for (let j = start; j < nums2.length; j++) {
            if (nums2[j] > nums1[i]) {
                arr.push(nums2[j]);
                isFind = true;
                break;
            }
        }
        if (!isFind) {
            arr.push(-1);
        }
    }
    return arr;
};
var nums1 = [2, 4];
var nums2 = [1,2,3,4];
console.log(nextGreaterElement(nums1, nums2));
```

# 500. 键盘行

给定一个单词列表，只返回可以使用在键盘同一行的字母打印出来的单词。键盘如下图所示。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/keyboard.png) 

**示例：**

> 输入: ["Hello", "Alaska", "Dad", "Peace"]
> 输出: ["Alaska", "Dad"]
 
**注意：**

你可以重复使用键盘上同一字符。
你可以假设输入的字符串将只包含字母。

**Answer**

```js
/**
 * @param {string[]} words
 * @return {string[]}
 */
var findWords = function(words) {
    var pattern = /^([qwertyuiop]+|[asdfghjkl]+|[zxcvbnm]+)$/i;
    return words.filter((item) => {
        return pattern.test(item)
    })
};
var words = ["Hello", "Alaska", "Dad", "Peace"]
console.log(findWords(words));
```

# 504. 七进制数

给定一个整数，将其转化为7进制，并以字符串形式输出。

**示例 1:**

> 输入: 100
> 输出: "202"

**示例 2:**

> 输入: -7
> 输出: "-10"

注意: 输入范围是 [-1e7, 1e7] 。

**Answer**

*法一：常规进制转换*

```js
/**
 * @param {number} num
 * @return {string}
 */
var convertToBase7 = function(num) {
    if (num == 0) return '0';
    let str = '';
    let radix = 7;
    let isPositiveNum = true;
    if(num < 0){
        num = -num;
        isPositiveNum = false;
    }
    while (num > 0) {
    	str = num % radix + str;
    	num = parseInt(num / 7);
    }
    return isPositiveNum ? str : '-' + str; 
};
var num = 99;
console.log(convertToBase7(num));
```

*法二： 原生API*

Number.prototype.toString([radix])

```js
var convertToBase7 = function(num) {
    return (num).toString(7);
};
```

# 506. 相对名次

给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（"Gold Medal", "Silver Medal", "Bronze Medal"）。

(注：分数越高的选手，排名越靠前。)

**示例 1:**

> 输入: [5, 4, 3, 2, 1]
> 输出: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]
解释: 前三名运动员的成绩为前三高的，因此将会分别被授予 “金牌”，“银牌”和“铜牌” ("Gold Medal", "Silver Medal" and "Bronze Medal").
余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。

**提示:**

N 是一个正整数并且不会超过 10000。
所有运动员的成绩都不相同。

```js
/**
 * @param {number[]} nums
 * @return {string[]}
 */
var findRelativeRanks = function(nums) {
    let nums2 = [...nums];
    nums2.sort((a, b) => b - a);
    let arr = [];
    for (let i = 0; i < nums.length; i++) {
        if (nums2.indexOf(nums[i]) === 0) {
            arr.push('Gold Medal')
        } else if (nums2.indexOf(nums[i]) === 1) {
            arr.push('Silver Medal')
        } else if (nums2.indexOf(nums[i]) === 2) {
            arr.push('Bronze Medal')
        } else {
            arr.push(nums2.indexOf(nums[i]) + 1 + '')
        }
    }
    return arr
};
var nums = [9, 4, 7, 3, 1, 6];
console.log(nums);
console.log(findRelativeRanks(nums));
```

```js
var findRelativeRanks2 = function(nums) {
    let nums2 = [...nums];
    nums2.sort((a, b) => b - a);
    let arr = [];
    let gold = nums.indexOf(nums2[0]);
    let silver = nums.indexOf(nums2[1]);
    let bronze = nums.indexOf(nums2[2]);
    for (let i = 0; i < nums.length; i++) {
        arr.push(nums2.indexOf(nums[i]) + 1 + '')
    }
    arr[gold] = 'Gold Medal';
    arr[silver] = 'Silver Medal';
    arr[bronze] = 'Bronze Medal';
    return arr
};
console.log(findRelativeRanks2(nums));
```

# 507. 完美数

对于一个 正整数，如果它和除了它自身以外的所有正因子之和相等，我们称它为“完美数”。

给定一个 整数 n， 如果他是完美数，返回 True，否则返回 False

**示例：**

> 输入: 28
> 输出: True
解释: 28 = 1 + 2 + 4 + 7 + 14
 

**提示：**

输入的数字 n 不会超过 100,000,000. (1e8)

**Answer**

```js
/**
 * @param {number} num
 * @return {boolean}
 */
var checkPerfectNumber = function(num) {
    let res = 0;
    if (num === 1) return false;
    let middle = parseInt(Math.sqrt(num));
    while(middle > 1) {
        if (num % middle === 0) {
        	res += middle + num/middle
        }
        middle--
    }
    return res + 1 === num
};
var num = 1;
console.log(checkPerfectNumber(num));
```

# 509. 斐波那契数

斐波那契数，通常用 F(n) 表示，形成的序列称为斐波那契数列。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0,   F(1) = 1
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
给定 N，计算 F(N)。

**示例 1：**

> 输入：2
> 输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1.

**示例 2：**

> 输入：3
> 输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2.

**示例 3：**

> 输入：4
> 输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3.
 

**提示：**

0 ≤ N ≤ 30


**Answer**

```js
/**
 * @param {number} N
 * @return {number}
 */
var fib = function(N) {
    let arr = [0, 1];
    for(let i = 2; i <= N; i++) {
        arr[i] = arr[i-2] + arr[i-1];
    }
    return arr[N]
};
var N = 4;
console.log(fib(N));
```

# 520. 检测大写字母【12/1】

给定一个单词，你需要判断单词的大写使用是否正确。

我们定义，在以下情况时，单词的大写用法是正确的：

全部字母都是大写，比如"USA"。
单词中所有字母都不是大写，比如"leetcode"。
如果单词不只含有一个字母，只有首字母大写， 比如 "Google"。
否则，我们定义这个单词没有正确使用大写字母。

**示例 1:**

> 输入: "USA"
> 输出: True

**示例 2:**

> 输入: "FlaG"
> 输出: False

注意: 输入是由大写和小写拉丁字母组成的非空单词。

**Answer**

*法一*

```js
/**
 * @param {string} word
 * @return {boolean}
 */
var detectCapitalUse = function(word) {
    if (word.toUpperCase() == word || word.toLowerCase() == word) {
    	return true;
    }
    if (/[A-Z]/.test(word[0])) {
        if (word.substr(1).toLowerCase() == word.substr(1)) {
        	return true
        } else {
        	return false
        }
    }
    return false
};
var word = 'MyT';
console.log(detectCapitalUse(word));
```

*法二：正则匹配*

```js
var detectCapitalUse2 = function(word) {
    let patterns = [/^[A-Z]+$/, /^[a-z]+$/, /^[A-Z][a-z]+$/];
    let flag = false
    patterns.forEach((item) => {
        if (item.test(word)) {
        	flag = true
        }
    })
    return flag
};
console.log(detectCapitalUse(word));
```

# 551. 学生出勤记录 I

给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符：

'A' : Absent，缺勤
'L' : Late，迟到
'P' : Present，到场
如果一个学生的出勤记录中不超过一个'A'(缺勤)并且不超过两个连续的'L'(迟到),那么这个学生会被奖赏。

你需要根据这个学生的出勤记录判断他是否会被奖赏。

**示例 1:**

> 输入: "PPALLP"
> 输出: True

**示例 2:**

> 输入: "PPALLL"
> 输出: False

**Answer**

```js
/**
 * @param {string} s
 * @return {boolean}
 */
var checkRecord = function(s) {
    if (s.indexOf('A') === s.lastIndexOf('A')) {
        for (let i = 0; i < s.length-2; i++) {
            if (s[i] === 'L' && s[i+1] === 'L' && s[i+2] === 'L') {
                return false;
            }
        }
    } else {
        return false;
    }
    return true;
};
var s = "APPLL";
console.log(checkRecord(s));
```

```js
var checkRecord2 = function(s) {
    if (s.indexOf('A') === s.lastIndexOf('A') && s.indexOf('LLL') === -1) {
        return true;
    } else {
        return false;
    }
};
```

```js
var checkRecord3 = function(s) {
    let pat1 = /.*A+.*A+.*/;
    let pat2 = /L{3,}/;
    return !pat1.test(s) && !pat2.test(s);
};
console.log(checkRecord3(s));
```

# 557. 反转字符串中的单词 III

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

**示例 1:**

> 输入: "Let's take LeetCode contest"
> 输出: "s'teL ekat edoCteeL tsetnoc" 

注意：在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。

**Answer**

```js
/**
 * @param {string} s
 * @return {string}
 */
var reverseWords = function(s) {
    let arr = s.split(' ');
    let arr2 = [];
    for(let i = 0; i < arr.length; i++) {
        arr2.push(arr[i].split('').reverse().join(''))
    }
    return arr2.join(' ');
};
var s = "Let's take LeetCode contest";
console.log(reverseWords(s));
```


# 575. 分糖果

给定一个偶数长度的数组，其中不同的数字代表着不同种类的糖果，每一个数字代表一个糖果。你需要把这些糖果平均分给一个弟弟和一个妹妹。返回妹妹可以获得的最大糖果的种类数。

**示例 1:**

> 输入: candies = [1,1,2,2,3,3]
> 输出: 3
解析: 一共有三种种类的糖果，每一种都有两个。
     最优分配方案：妹妹获得[1,2,3],弟弟也获得[1,2,3]。这样使妹妹获得糖果的种类数最多。

**示例 2 :**

> 输入: candies = [1,1,2,3]
> 输出: 2
解析: 妹妹获得糖果[2,3],弟弟获得糖果[1,1]，妹妹有两种不同的糖果，弟弟只有一种。这样使得妹妹可以获得的糖果种类数最多。

**注意:**

数组的长度为[2, 10,000]，并且确定为偶数。
数组中数字的大小在范围[-100,000, 100,000]内。

**Answer**

```js
/**
 * @param {number[]} candies
 * @return {number}
 */
var distributeCandies = function(candies) {
    const size = new Set(candies).size
    if(size >= candies.length / 2) {
        return candies.length / 2
    } else {
        return size
    }
    // return Math.min([...new Set(candies)].length, candies.length/2)
};
var candies = [1,1,2,2,3,3];
console.log(distributeCandies(candies));
```

# 581. 最短无序连续子数组

给定一个整数数组，你需要寻找一个连续的子数组，如果对这个子数组进行升序排序，那么整个数组都会变为升序排序。

你找到的子数组应是最短的，请输出它的长度。

**示例 1:**

> 输入: [2, 6, 4, 8, 10, 9, 15]
> 输出: 5
解释: 你只需要对 [6, 4, 8, 10, 9] 进行升序排序，那么整个表都会变为升序排序。

**说明 :**

输入的数组长度范围在 [1, 10,000]。
输入的数组可能包含重复元素 ，所以升序的意思是<=。

**Answer**

排序后，双指针对比

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findUnsortedSubarray = function(nums) {
    let nums2 = [...nums];
    nums.sort((a, b) => a - b);
    let i = 0;
    let j = nums.length-1;
    while(i < j) {
    	if (nums[i] === nums2[i]) {
    		i++;
    	} else if(nums[j] === nums2[j]) {
    		j--;
    	} else if (nums[i] !== nums2[i] && nums[j] !== nums2[j]) {
    		break;
    	}
    }
    if (i === j) {
    	return 0
    } else {
    	return j - i + 1
    }
};
var nums = [2, 6, 4, 8, 10, 9, 15];
console.log(findUnsortedSubarray(nums));
```

# 594. 最长和谐子序列

和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。

现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。

**示例 1:**

> 输入: [1,3,2,2,5,2,3,7]
> 输出: 5
原因: 最长的和谐数组是：[3,2,2,2,3].

说明: 输入的数组长度最大不超过20,000.

**Answer**

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findLHS = function(nums) {
    let map = new Map();
    let max = 0;
    for(let i = 0; i < nums.length; i++) {
        if(map.has(nums[i])) {
            map.set(nums[i], map.get(nums[i]) + 1)
        } else {
            map.set(nums[i], 1)
        }
    }
    for(let [key,value] of map){
        if(map.has(key+1)) {
            max = Math.max(max,map.get(key+1) + value);
        }
    }
    return max;
};
var nums = [1,3,2,2,5,2,3,7];
console.log(findLHS(nums));
```


# 598. 范围求和 II

给定一个初始元素全部为 0，大小为 m*n 的矩阵 M 以及在 M 上的一系列更新操作。

操作用二维数组表示，其中的每个操作用一个含有两个正整数 a 和 b 的数组表示，含义是将所有符合 0 <= i < a 以及 0 <= j < b 的元素 M[i][j] 的值都增加 1。

在执行给定的一系列操作后，你需要返回矩阵中含有最大整数的元素个数。

**示例 1:**

> 输入: 
m = 3, n = 3
operations = [[2,2],[3,3]]
> 输出: 4

解释: 
初始状态, M = 
[[0, 0, 0],
 [0, 0, 0],
 [0, 0, 0]]

执行完操作 [2,2] 后, M = 
[[1, 1, 0],
 [1, 1, 0],
 [0, 0, 0]]

执行完操作 [3,3] 后, M = 
[[2, 2, 1],
 [2, 2, 1],
 [1, 1, 1]]

M 中最大的整数是 2, 而且 M 中有4个值为2的元素。因此返回 4。

**注意:**

m 和 n 的范围是 [1,40000]。
a 的范围是 [1,m]，b 的范围是 [1,n]。
操作数目不超过 10000。

**Answer**

每次操作都是左上角区域从（0, 0）到（a, b）的矩形，必定重叠，所以找最小的a乘最小的b就行
```js
/**
 * @param {number} m
 * @param {number} n
 * @param {number[][]} ops
 * @return {number}
 */
var maxCount = function(m, n, ops) {
    for (let i = 0; i < ops.length; i++) {
        m = Math.min(m, ops[i][0])
        n = Math.min(n, ops[i][1])
    }
    return m * n
};
var m = 3
var n = 3
var operations = [[2,2],[3,3]];
console.log(maxCount(m, n, ops));
```

# 599. 两个列表的最小索引总和

假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。

你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。

**示例 1:**

> 输入:
["Shogun", "Tapioca Express", "Burger King", "KFC"]
["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]
> 输出: ["Shogun"]
解释: 他们唯一共同喜爱的餐厅是“Shogun”。

**示例 2:**

> 输入:
["Shogun", "Tapioca Express", "Burger King", "KFC"]
["KFC", "Shogun", "Burger King"]
> 输出: ["Shogun"]
解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。

**提示:**

1. 两个列表的长度范围都在 [1, 1000]内。
2. 两个列表中的字符串的长度将在[1，30]的范围内。
3. 下标从0开始，到列表的长度减1。
4. 两个列表都没有重复的元素。

**Answer**

```js
/**
 * @param {string[]} list1
 * @param {string[]} list2
 * @return {string[]}
 */
var findRestaurant = function(list1, list2) {
    let map = new Map();
    let res = [];
    list1.forEach((item) => {
    	if (list2.indexOf(item) !== -1) {
            map.set(item, list1.indexOf(item) + list2.indexOf(item))
    	}
    });
    // 最小索引和
    let min = Math.min.apply(Math, [...map.values()])
    for (let [key, val] of map) {
        if (val === min) {
        	res.push(key)
        }
    }
    return res
};
var list1 = ["Shogun", "Tapioca Express", "Burger King", "KFC"]
var list2 = ["KFC", "Shogun", "Burger King"];
console.log(findRestaurant(list1, list2));
```

# 605. 种花问题

假设你有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花卉不能种植在相邻的地块上，它们会争夺水源，两者都会死去。

给定一个花坛（表示为一个数组包含0和1，其中0表示没种植花，1表示种植了花），和一个数 n 。能否在不打破种植规则的情况下种入 n 朵花？能则返回True，不能则返回False。

**示例 1:**

输入: flowerbed = [1,0,0,0,1], n = 1
输出: True

**示例 2:**

输入: flowerbed = [1,0,0,0,1], n = 2
输出: False

**注意:**

1. 数组内已种好的花不会违反种植规则。
2. 输入的数组长度范围为 [1, 20000]。
3. n 是非负整数，且不会超过输入数组的大小。

**Answer**

防御式编程思想：在 flowerbed 数组两端各增加一个 0， 这样处理的好处在于不用考虑边界条件，任意位置处只要连续出现三个 0 就可以栽上一棵花。

```js
/**
 * @param {number[]} flowerbed
 * @param {number} n
 * @return {boolean}
 */
var canPlaceFlowers = function(flowerbed, n) {
    flowerbed.unshift(0)
    flowerbed.push(0)
    let count = 0;
    let len = flowerbed.length;
    for (let i = 0; i < len; i++) {
        if (flowerbed[i-1] === 0 && flowerbed[i] === 0 && flowerbed[i+1] === 0) {
            flowerbed[i] = 1;
            count++
        }
    }
    return count >= n;
};
var flowerbed = [1,0,0,0,1];
var n = 1;
console.log(canPlaceFlowers(flowerbed, n));
```

# 628. 三个数的最大乘积

给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。

**示例 1:**

> 输入: [1,2,3]
> 输出: 6

**示例 2:**

> 输入: [1,2,3,4]
> 输出: 24

**注意:**

1. 给定的整型数组长度范围是[3,104]，数组中所有的元素范围是[-1000, 1000]。
2. 输入的数组中任意三个数的乘积不会超出32位有符号整数的范围。

**Answer**

无论有多少正数或者负数,首先一定会选择最大数即nums[n-1],然后无非就是选择开头两位还是倒数两位

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var maximumProduct = function(nums) {
    nums.sort((a, b) => a - b);
    let len = nums.length;
    let product1 = nums[len-1] * nums[0] * nums[1];
    let product2 = nums[len-1] * nums[len-2] * nums[len-3];
    return Math.max(product1,product2);
};
var nums = [-1,-2,-3,-4];
console.log(maximumProduct(nums));
```

# 643. 子数组最大平均数 I

给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。

**示例 1:**

> 输入: [1,12,-5,-6,50,3], k = 4
> 输出: 12.75
解释: 最大平均数 (12-5-6+50)/4 = 51/4 = 12.75

**注意:**

1. 1 <= k <= n <= 30,000。
2. 所给数据范围 [-10,000，10,000]。

**Answer**

```js
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number}
 */
var findMaxAverage = function(nums, k) {
    let len = nums.length;
    let arr = [];
    for(let i = 0; i <= len-k; i++) {
    	let sum = 0;
        for (let j = i; j < k+i; j++) {
            sum += nums[j]
        }
        arr.push(sum);
    }
    return Math.max.apply(Math, arr) / k;
};
var nums = [1,12,-5,-6,50,3];
var k = 4;
console.log(findMaxAverage(nums, k));
```

# 645. 错误的集合

集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。

给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。

**示例 1:**

> 输入: nums = [1,2,2,4]
> 输出: [2,3]

**注意:**

1. 给定数组的长度范围是 [2, 10000]。
2. 给定的数组是无序的。

**Answer**

```js
/**
 * @param {number[]} nums
 * @return {number[]}
 */
 /** 使用indexOf 比减法慢太多了 **/
var findErrorNums = function(nums) {
    let len = nums.length;
    let repeat;
    let lack;
    for (let i = 1; i <= len; i++) {
        if (nums.indexOf(i) === -1) {
            lack = i
        }
        if (nums.indexOf(i) !== nums.lastIndexOf(i)) {
            repeat = i
        }
    }
    return [repeat, lack];
};
var nums = [3,2,3,4,6,5];
console.log('nums',nums.sort());
//console.log(findErrorNums(nums));
```

```js
var findErrorNums2 = function(nums) {
    let len = nums.length;
    let repeat;
    let lack;
    let unique = [...new Set(nums)];
    let map = new Map();
    let arr = []
    for (let i = 0; i < len; i++) {
        if (!map.has(nums[i])) {
            map.set(nums[i], true)
        } else {
            repeat = nums[i]
        }
        arr.push(i+1)
    }
    lack = arr.filter((item) => {
        return unique.indexOf(item) == -1
    })
    return [repeat, lack[0]];
};
console.log(findErrorNums2(nums));
```

```js
var findErrorNums3 = function(nums) {
    let len = nums.length;
    let repeat;
    let lack;
    let unique = [...new Set(nums)];
    let map = new Map();
    let arr = []
    let sum = (1 + len ) * len / 2;
    for (let i = 0; i < len; i++) {
        if (!map.has(nums[i])) {
            map.set(nums[i], true)
        } else {
            repeat = nums[i]
        }
        arr.push(i+1)
    }
    for (let j = 0; j < unique.length; j++) {
        sum -= unique[j]
    }
    return [repeat, sum];
};
console.log(findErrorNums3(nums));
```

```js
var findErrorNums4 = function(nums) {
    let len = nums.length;
    let repeat;
    let lost;
    let map = new Map();
    let wrongSum = 0;
    let rightSum = (1 + len ) * len / 2;
    for (let i = 0; i < len; i++) {
        if (!map.has(nums[i])) {
            map.set(nums[i], true)
        } else {
            repeat = nums[i]
        }
        wrongSum += nums[i]
    }
    lost = rightSum - (wrongSum-repeat);
    return [repeat, lost];
};
console.log(findErrorNums4(nums));
```

```js
var findErrorNums5 = function(nums) {
    //有一个元素重复  nums是无序的
    //新建一个数组
    var arr = new Array(nums.length).fill(0);
    let res1 = 0,res2 = 0;
    for(let i  of nums){
        arr[i-1]++;
        if (arr[i-1] == 2) {
            res1 = i
        };
    }
    for(let i = 0; i < arr.length; ++i){
        if (arr[i] == 0) {
            return [res1, i+1];
        } 
    }
    return [];
};
console.log(findErrorNums5(nums));
```

```js
var findErrorNums6 = function(nums) {
    var res = [];
    for (let i = 0; i < nums.length; i++) {
        var absN = Math.abs(nums[i]) - 1
        if (nums[absN] < 0) {
            res.push(Math.abs(nums[i]))
        } else {
            nums[absN] = - nums[absN]
        }
    }
    var s
    nums.forEach((i,idx) => s = i > 0 ? (idx + 1) : s)
    return res.concat(s)
};
console.log(findErrorNums6(nums));
```

# 657. 机器人能否返回原点

在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。

移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后返回原点，则返回 true。否则，返回 false。

注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。

**示例 1:**

> 输入: "UD"
> 输出: true
解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。

**示例 2:**

> 输入: "LL"
> 输出: false
解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。

**Answer**

*法一*

```js
/**
 * @param {string} moves
 * @return {boolean}
 */
var judgeCircle = function(moves) {
    let countR = 0;
    let countU = 0;
    let len = moves.length;
    for (let i = 0; i < len; i++) {
        if (moves[i] == 'R') {
            countR++
        } else if (moves[i] == 'L') {
            countR--
        } else if (moves[i] == 'U') {
            countU++
        } else {
            countU--
        }
    }
    return countR == 0 && countU == 0;
};
var moves = "DDRUULRL";
console.log(judgeCircle(moves));
```

*法二*

```js
var judgeCircle2 = function(moves) {
    // 判断 L.count === R.count && U.count === D.count
    return moves.split('L').length === moves.split('R').length && moves.split('U').length === moves.split('D').length
};
console.log(judgeCircle2(moves));
```

# 665. 非递减数列

给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。

我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 <= i < n)，满足 array[i] <= array[i + 1]。

**示例 1:**

> 输入: [4,2,3]
> 输出: True
解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。

**示例 2:**

> 输入: [4,2,1]
> 输出: False
解释: 你不能在只改变一个元素的情况下将其变为非递减数列。

说明:  n 的范围为 [1, 10,000]。

**Answer**

**思路：**

如果出现 a[i] > a[i+1]，那么还需要看a[i]前面的数a[i-1]与它后面的数a[i+1]，改变一个数，就面临两种选择:

1. 把a[i]变小
2. 把a[i+1] 变大


```js
/**
 * @param {number[]} nums
 * @return {boolean}
 */
var checkPossibility = function(nums) {
    let count = 0;
    if (nums[0] > nums[1]) {
        nums[0] = nums[1];
        count++
    }
    for (let i = 1; i < nums.length-1; i++) {
        let left = nums[i-1];
        let right = nums[i+1];
        if (nums[i] > nums[i+1]) {
            ++count;
            // 不用再向后看了
            if (count > 1) {
                return false
            }
            if (left > right) {
                nums[i+1] = nums[i]
            } else {
                nums[i] = left;
            }
        } 
    }
    return true
};
var nums = [3,4,2,3];
console.log(checkPossibility(nums));
```

# 674. 最长连续递增序列

给定一个未经排序的整数数组，找到最长且连续的的递增序列。

**示例 1:**

> 输入: [1,3,5,4,7]
> 输出: 3
解释: 最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为5和7在原数组里被4隔开。 

**示例 2:**

> 输入: [2,2,2,2,2]
> 输出: 1
解释: 最长连续递增序列是 [2], 长度为1。
注意：数组长度不会超过10000。

**Answer**

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findLengthOfLCIS = function(nums) {
    let arr = [];
    let len = nums.length;
    let count = 1;
    if (len == 0) {
        return 0;
    }
    for(let i = 0; i < len-1; i++) {
        if (nums[i] < nums[i+1]) {
            count++;
        } else {
            arr.push(count);
            count = 1
        }
    }
    arr.push(count);
    return Math.max.apply(Math, arr)
};
var nums = [1,3,5,4,7];
console.log(findLengthOfLCIS(nums));
```

```js
var findLengthOfLCIS2 = function(nums) {
    let max = 0;
    let len = nums.length;
    let count = 1;
    for(let i = 0; i < len; i++) {
        if (nums[i] < nums[i+1]) {
            count++;
        } else {
            max = Math.max(max, count)
            count = 1
        }
    }
    return max
};
console.log(findLengthOfLCIS2(nums));
```

# 680. 验证回文字符串 Ⅱ

给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。

**示例 1:**

> 输入: "aba"
> 输出: True

**示例 2:**

> 输入: "abca"
> 输出: True
解释: 你可以删除c字符。

**注意:**

字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。

**Answer**

```js
/**
 * @param {string} s
 * @return {boolean}
 */

// 验证是否是回文串
var isPalindrome = function(s, i = 0, j = s.length - 1) {
    while (i < j) {
        if(s[i] !== s[j]){
           return false;
        }
        i++;
        j--;
    }
    return true; 
};

var validPalindrome = function(s) {
    let i = 0;
    let j = s.length - 1;
    while(i < j) { 
        if (s[i] !== s[j]) {
            return isPalindrome(s, i + 1, j) || isPalindrome(s, i, j - 1)
        }
        i++;
        j--;
    }
    return true;
};
var s = 'babk';
console.log(validPalindrome(s));
```

# 686. 重复叠加字符串匹配

给定两个字符串 A 和 B, 寻找重复叠加字符串A的最小次数，使得字符串B成为叠加后的字符串A的子串，如果不存在则返回 -1。

举个例子，A = "abcd"，B = "cdabcdab"。

答案为 3， 因为 A 重复叠加三遍后为 “abcdabcdabcd”，此时 B 是其子串；A 重复叠加两遍后为"abcdabcd"，B 并不是其子串。

**注意:**

A 与 B 字符串的长度在1和10000区间范围内。

**Answer**

```js
/**
 * @param {string} A
 * @param {string} B
 * @return {number}
 */
var repeatedStringMatch = function(A, B) {
    let times = Math.ceil(B.length / A.length);
    let A2 = A.repeat(times);
    let A3 = A2 + A;
    if (A2.indexOf(B) !== -1) {
        return times;
    } else if (A3.indexOf(B) !== -1){
        return times + 1
    } else {
        return -1
    }
};
var A = "abcd";
var B = "cdabcdab";
console.log(repeatedStringMatch(A, B));
```

# 693. 交替位二进制数

给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。

**示例 1:**

> 输入: 5
> 输出: True
解释:
5的二进制数是: 101

**示例 2:**

> 输入: 7
> 输出: False
解释:
7的二进制数是: 111

**示例 3:**

> 输入: 11
> 输出: False
解释:
11的二进制数是: 1011

**示例 4:**

> 输入: 10
> 输出: True
解释:
10的二进制数是: 1010

**Answer**

```js
/**
 * @param {number} n
 * @return {boolean}
 */
var hasAlternatingBits = function(n) {
    let nto2 = n.toString(2);
    let pat = /^1(01)*0?$/;
    return pat.test(nto2);
};
var n = 10;
console.log(hasAlternatingBits(n));
```

# 696. 计数二进制子串

给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。

重复出现的子串要计算它们出现的次数。

**示例 1 :**

> 输入: "00110011"
> 输出: 6
解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。

请注意，一些重复出现的子串要计算它们出现的次数。

另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。

**示例 2 :**

> 输入: "10101"
> 输出: 4
解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。

**注意：**

1. s.length 在1到50,000之间。
2. s 只包含“0”或“1”字符。

**Answer**

```js
/**
 * @param {string} s
 * @return {number}
 */
var countBinarySubstrings = function(s) {
    //res存储相邻连续字符串的个数
    let res = [];
    let temp = s[0];
    let count = 0;
    for(let i of s){
        if(i !== temp) {
            res.push(count);
            temp = i;
            count = 0;
        }
        count++;
    }
    res.push(count);
    let total = 0;
    for(let i = 0; i < res.length-1; i++){
        total += Math.min(res[i],res[i+1]);
    }
    return total;
};
var s = '00110011';
console.log(countBinarySubstrings(s));
```

# 697. 数组的度


给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。

你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。

**示例 1:**

> 输入: [1, 2, 2, 3, 1]
> 输出: 2
解释: 
输入数组的度是2，因为元素1和2的出现频数最大，均为2.
连续子数组里面拥有相同度的有如下所示:
[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]
最短连续子数组[2, 2]的长度为2，所以返回2.

**示例 2:**

> 输入: [1,2,2,3,1,4,2]
> 输出: 6

**注意:**

- nums.length 在1到50,000区间范围内。
- nums[i] 是一个在0到49,999范围内的整数。

**Answer**

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var findShortestSubArray = function(nums) {
    let map = new Map();
    let len = nums.length;
    for(let item of nums) {
        if (!map.has(item)) {
            map.set(item, 1)
        } else {
            map.set(item, map.get(item)+1)
        }
    }
    let maxCount = Math.max.apply(Math, [...map.values()]);
    let maxVals = [];
    for(let [key, val] of map) {
        if(val === maxCount) {
            maxVals.push(key)
        }
    }
    let min = Number.MAX_SAFE_INTEGER;
    for (let item of maxVals) {
        let start = nums.indexOf(item);
        let end = nums.lastIndexOf(item) + 1;
        if (end - start < min) {
            min = end - start;
        }
    }
    return min;
};
var nums = [1,2,2,3,1];
console.log(findShortestSubArray(nums));
```

# 704. 二分查找

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

**示例 1:**

> 输入: nums = [-1,0,3,5,9,12], target = 9
> 输出: 4
解释: 9 出现在 nums 中并且下标为 4

**示例 2:**

> 输入: nums = [-1,0,3,5,9,12], target = 2
> 输出: -1
解释: 2 不存在 nums 中因此返回 -1
 
**提示：**

1. 你可以假设 nums 中的所有元素是不重复的。
2. n 将在 [1, 10000]之间。
3. nums 的每个元素都将在 [-9999, 9999]之间。

**Answer**

```js
/**
 * @param {number[]} nums
 * @param {number} target
 * @return {number}
 */
var search = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    while(left <= right) {
        let middle = parseInt((left + right) / 2);
        if (target === nums[middle]) {
            return middle;
        } else if (target < nums[middle]) {
            right = middle - 1;
        } else if (target > nums[middle]) {
            left = middle + 1;
        }
    }
    return -1;
};
var nums = [-1,3,4];
var target = 4;
console.log(search(nums, target));
```

# 709. 转换成小写字母

实现函数 ToLowerCase()，该函数接收一个字符串参数 str，并将该字符串中的大写字母转换成小写字母，之后返回新的字符串。

**示例 1：**

> 输入: "Hello"
> 输出: "hello"

**示例 2：**

> 输入: "here"
> 输出: "here"

**示例 3：**

> 输入: "LOVELY"
> 输出: "lovely"

**Answer**

*法一*

```js
/**
 * @param {string} str
 * @return {string}
 */
var toLowerCase = function(str) {
    let obj = {
        'A': 'a',
        'B': 'b',
        'C': 'c',
        'D': 'd',
        'E': 'e',
        'F': 'f',
        'G': 'g',
        'H': 'h',
        'I': 'i',
        'J': 'j',
        'K': 'k',
        'L': 'l',
        'M': 'm',
        'N': 'n',
        'O': 'o',
        'P': 'p',
        'Q': 'q',
        'R': 'r',
        'S': 's',
        'T': 't',
        'U': 'u',
        'V': 'v',
        'W': 'w',
        'X': 'x',
        'Y': 'y',
        'Z': 'z',
    };
    let res = '';
    for (let i = 0; i < str.length; i++) {
        if (obj[str[i]]) {
            res += obj[str[i]]
        } else {
            res += str[i]
        }
    }
    return res;
};
var str = 'AbC'
console.log(toLowerCase(str));
```

*法二*

```js
var toLowerCase = function(str) {
  let ret = ''
  for(let i = 0; i < str.length; i++){
    let code = str.charCodeAt(i)
    if(code <= 90 && code>=65){
      ret += String.fromCharCode(code + 32)
    }else{
      ret += str[i]
    }
  }
  return ret
};
```

# 717. 1比特与2比特字符

有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。

现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。

**示例 1:**

> 输入: 
bits = [1, 0, 0]
> 输出: True
解释: 
唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。

**示例 2:**

> 输入: 
bits = [1, 1, 1, 0]
> 输出: False
解释: 
唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。

**注意:**

- 1 <= len(bits) <= 1000.
- bits[i] 总是0 或 1.

**Answer**

*法一：*

只与最后一个元素0的前面的连续1的个数有关系。

```js
/**
 * @param {number[]} bits
 * @return {boolean}
 */
var isOneBitCharacter = function(bits) {
    let last1count = 0;
    for (let i = bits.length - 2; i >= 0; i--) {
        if(bits[i] === 1) {
            last1count++;
        } else {
            break;
        }
    }
    return last1count % 2 === 0 
};
var bits = [1,1,1,0]
console.log(isOneBitCharacter(bits));
```

*法二*

```js
var isOneBitCharacter2 = function(bits) {
    let pat = /^(10|11|0)*0$/;
    let str = bits.join('');
    return pat.test(str)
};
```

# 720. 词典中最长的单词

给出一个字符串数组words组成的一本英语词典。从中找出最长的一个单词，该单词是由words词典中其他单词逐步添加一个字母组成。若其中有多个可行的答案，则返回答案中字典序最小的单词。

若无答案，则返回空字符串。

**示例 1:**

> 输入: 
words = ["w","wo","wor","worl", "world"]
> 输出: "world"
解释: 
单词"world"可由"w", "wo", "wor", 和 "worl"添加一个字母组成。

**示例 2:**

> 输入: 
words = ["a", "banana", "app", "appl", "ap", "apply", "apple"]
> 输出: "apple"
解释: 
"apply"和"apple"都能由词典中的单词组成。但是"apple"得字典序小于"apply"。

**注意:**

- 所有输入的字符串都只包含小写字母。
- words数组长度范围为[1,1000]。
- words[i]的长度范围为[1,30]。

**Answer**

```js
/**
 * @param {string[]} words
 * @return {string}
 */
var longestWord = function(words) {
    // 按照字典顺序排序
    words.sort();
    let set = new Set();
    res = '';
    for(let item of words) {
        if(item.length == 1 || set.has(item.substring(0, item.length - 1))) {
            // 预防长度一定时， 后面的'apply' 会覆盖前面的 'apple'
            res = item.length > res.length ? item : res;
            set.add(item);
        }
    }
    return res
};
var words = ["a","banana","app","appl","ap","apply","apple"];
console.log(longestWord(words));
```

# 724. 寻找数组的中心索引

给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。

我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。

如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。

**示例 1:**

> 输入: 
nums = [1, 7, 3, 6, 5, 6]
> 输出: 3
解释: 
索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。
同时, 3 也是第一个符合要求的中心索引。

**示例 2:**

> 输入: 
nums = [1, 2, 3]
> 输出: -1
解释: 
数组中不存在满足此条件的中心索引。

**说明:**

- nums 的长度范围为 [0, 10000]。
- 任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。

**Answer**

*法一：求中心索引左右两边的和*

缺点：太慢

```js
var pivotIndex = function(nums) {
    let add = function(arr) {
        var s = 0;
            for (var i = arr.length-1; i >= 0; i--) {
                s += arr[i];
            }
        return s;
    }
    let sum = add(nums);
    let len = nums.length;
    for (let i = 0; i < len; i++) {
        halfSum = (sum - nums[i]) / 2;
        leftArr = nums.slice(0,i).length !== 0 ? nums.slice(0,i) : nums[i];
        rightArr = nums.slice(i+1,len);
        leftSum = add(leftArr)
        rightSum = add(rightArr)
        if (leftSum == rightSum) {
            return i
        }
    }
    return -1
};
var nums = [1, 7, 3, 6, 5, 6];
//var nums = [-1,-1,-1,-1,-1,-1];
//var nums = [1, 5, 6, 4, 2];
//var nums = [-1,-1,-1,-1,-1,0];
//var nums = [-1,-1,-1,0,1,1];
//var nums = [3, 2, 1];
//console.log(pivotIndex(nums));
```

*法二：只求中心索引左边的和*

改进法一

1. sumLeft + sumRight + nums[i] = sumTotal;
2. sumLeft = sumRight
3. 可以得出 sumLeft * 2 + nums[i] = sumTotal;

```js
var pivotIndex2 = function(nums) {
    let len = nums.length;
    let sumTotal = 0;
    for (var i = len - 1; i >= 0; i--) {
        sumTotal += nums[i];
    }
    let leftSum = 0;
    for (let i = 0; i < len; i++) {
        if (leftSum * 2 == sumTotal - nums[i]) {
            return i
        }
        leftSum += nums[i];
    }
    return -1
};
```

*法三：双指针*

最终失败，

原因：无法处理负数，比如 [-1,-1,-1,-1,-1,0]

# 728. 自除数

`自除数` 是指可以被它包含的每一位数除尽的数。

例如，128 是一个自除数，因为 128 % 1 == 0，128 % 2 == 0，128 % 8 == 0。

还有，自除数不允许包含 0 。

给定上边界和下边界数字，输出一个列表，列表的元素是边界（含边界）内所有的自除数。

**示例 1：**

> 输入： 
上边界left = 1, 下边界right = 22
> 输出： [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22]

**注意：**

- 每个输入参数的边界满足 1 <= left <= right <= 10000。

**Answer**

*法一：暴力挨个判断*

```js
/**
 * @param {number} left
 * @param {number} right
 * @return {number[]}
 */
var selfDividingNumbers = function(left, right) {
    // 判断是否是自除数
    let isSelfDividingNumber = function(num) {
        let arr = [];
        let num2 = num;
        if (num2 === 0) {
            return false
        }
        while(num > 0) {
            arr.unshift(num % 10);
            num = parseInt(num / 10)
        }
        for (let item of arr) {
            if (num2 % item !== 0) {
                return false
            }
        }
        return true
    }
    let res = []
    for (let i = left; i <= right; i++) {
        if (isSelfDividingNumber(i)) {
            res.push(i)
        }
    }
    return res;
};
var left = 1;
var right = 22;
console.log(selfDividingNumbers(left, right));
```

*法二：优化法一*

```js
var selfDividingNumbers = function (left, right) {
    let arr = [];
    for(let i = left; i <= right; i++) {
        if (i < 10) {
            arr.push(i);
        } else if (i > 10) {
            let n = i.toString();
            let flag = true;
            for (let j = 0; j < n.length; j++) {
                if (i % n[j] != 0) {
                    flag = false
                }
            }
            if (flag) {
                arr.push(i)
            }
        }
    }
    return arr
};
```

# 744. 寻找比目标字母大的最小字母

给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。

数组里字母的顺序是循环的。举个例子，如果目标字母target = 'z' 并且有序数组为 letters = ['a', 'b']，则答案返回 'a'。

**示例:**

1
> 输入:
letters = ["c", "f", "j"]
target = "a"
> 输出: "c"

2

> 输入:
letters = ["c", "f", "j"]
target = "c"
> 输出: "f"

3

> 输入:
letters = ["c", "f", "j"]
target = "d"
> 输出: "f"

4

> 输入:
letters = ["c", "f", "j"]
target = "g"
> 输出: "j"

5

> 输入:
letters = ["c", "f", "j"]
target = "j"
> 输出: "c"

6

> 输入:
letters = ["c", "f", "j"]
target = "k"
> 输出: "c"

**注:**

1. letters长度范围在[2, 10000]区间内。
2. letters 仅由小写字母组成，最少包含两个不同的字母。
3. 目标字母target 是一个小写字母。

**Answer**

*法一*

```js
/**
 * @param {character[]} letters
 * @param {character} target
 * @return {character}
 */
var nextGreatestLetter = function(letters, target) {
    for(let i = 0; i < letters.length; i++){
        if(letters[i] > target){
            return letters[i]
        }
    }
    return letters[0]
};
var letters = ['a', 'c', 'e', 'f', 'g', 'i'];
var target = 'f';
console.log(nextGreatestLetter(letters, target));
```

*法二：二分法*

```js
var nextGreatestLetter2 = function(letters, target) {
    let left = 0;
    let right = letters.length - 1;
    while(left <= right) {
        let middle = parseInt((left + right) / 2);
        if (target < letters[middle]) {
            right = middle - 1;
        } else {
            left = middle + 1;
        }
    }
    return letters[left % letters.length];
};
```

# 746. 使用最小花费爬楼梯

数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。

每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。

您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。

**示例 1:**

> 输入: cost = [10, 15, 20]
输出: 15
> 解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。
 
**示例 2:**

> 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
> 输出: 6
解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。

**注意：**

1. cost 的长度将会在 [2, 1000]。
2. 每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。


**Answer**

动态规划

f(n) = min(f(n-1), f(n-2)) + cost[n]

```js
/**
 * @param {number[]} cost
 * @return {number}
 */
var minCostClimbingStairs = function(cost) {
    
    let len = cost.length;
    let arr = [];
    arr[0] = cost[0];
    arr[1] = cost[1];

    for(let i = 2; i < len; i++) {
        arr[i] = Math.min(arr[i-1] , arr[i-2]) + cost[i]
    }

    return Math.min(arr[len-1], arr[len-2]);
};
//var cost = [2,4,0,0];
var cost = [0, 1, 2, 2];
//var cost = [1, 0 , 0, 1];
//var cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1];
//var cost = [2, 1, 100, 40];
console.log(minCostClimbingStairs(cost));
```

# 747. 至少是其他数字两倍的最大数

在一个给定的数组nums中，总是存在一个最大元素 。

查找数组中的最大元素是否至少是数组中每个其他数字的两倍。

如果是，则返回最大元素的索引，否则返回-1。

**示例 1:**

> 输入: nums = [3, 6, 1, 0]
> 输出: 1
解释: 6是最大的整数, 对于数组中的其他整数,
6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.
 
**示例 2:**

> 输入: nums = [1, 2, 3, 4]
> 输出: -1
解释: 4没有超过3的两倍大, 所以我们返回 -1.
 
**提示:**

1. nums 的长度范围在[1, 50].
2. 每个 nums[i] 的整数范围在 [0, 100].

**Answer**

*法一*

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var dominantIndex = function(nums) {
    if (nums.length == 1) {
        return 0
    }
    var nums2 = [...nums];
    nums.sort((a, b) => b -a);
    if(nums[0] >= 2*nums[1]) {
        return nums2.indexOf(nums[0])
    } else {
        return -1
    }
    
};
var nums = [3, 6, 1, 0];
console.log(dominantIndex(nums));
```

*法二*

```js
var dominantIndex = function(nums) {
    if (nums.length==0)
        return -1;
    if (nums.length==1)
        return 0;
    let max = 0;
    let index = 0;
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] > max){
            max = nums[i];
            index = i;
        }
    }
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] != max && nums[i]*2 > max)
            return -1;
    }
    return index;
}
```

# 748. 最短完整词

如果单词列表（words）中的一个单词包含牌照（licensePlate）中所有的字母，那么我们称之为完整词。在所有完整词中，最短的单词我们称之为最短完整词。

单词在匹配牌照中的字母时不区分大小写，比如牌照中的 "P" 依然可以匹配单词中的 "p" 字母。

我们保证一定存在一个最短完整词。当有多个单词都符合最短完整词的匹配条件时取单词列表中最靠前的一个。

牌照中可能包含多个相同的字符，比如说：对于牌照 "PP"，单词 "pair" 无法匹配，但是 "supper" 可以匹配。

**示例 1：**

> 输入：licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"]
> 输出："steps"
说明：最短完整词应该包括 "s"、"p"、"s" 以及 "t"。对于 "step" 它只包含一个 "s" 所以它不符合条件。同时在匹配过程中我们忽略牌照中的大小写。
 
**示例 2：**

> 输入：licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"]
> 输出："pest"
说明：存在 3 个包含字母 "s" 且有着最短长度的完整词，但我们返回最先出现的完整词。
 
**注意:**

1. 牌照（licensePlate）的长度在区域[1, 7]中。
2. 牌照（licensePlate）将会包含数字、空格、或者字母（大写和小写）。
3. 单词列表（words）长度在区间 [10, 1000] 中。
4. 每一个单词 words[i] 都是小写，并且长度在区间 [1, 15] 中。

**Answer**

```js
/**
 * @param {string} licensePlate
 * @param {string[]} words
 * @return {string}
 */
var shortestCompletingWord = function(licensePlate, words) {
    // 有效牌照，只包含小写字母
    let license = licensePlate.replace(/[^a-zA-Z]/g, '').toLowerCase();
    // 存储包含有效牌照的所有单词，及其length
    let map = new Map();
    for (let i = 0; i < words.length; i++) {
        let flag = true;
        let str = words[i];
        for (let j = 0; j < license.length; j++) {
            let index = str.indexOf(license[j]);
            if (index == -1) {
                flag = false;
                break;
            } else {
                // 处理有效牌照中出现相同的字母
                str = str.slice(0, index) + str.slice(index + 1, str.length)
            }
        }
        if (flag) {
            map.set(words[i], words[i].length)
        } 
    }
    // 最小length的完整词
    let minVals = [];
    // 完整词的最小length
    let minIndex = Math.min.apply(Math, [...map.values()]);
    for (let [key, val] of map) {
        if (minIndex == val) {
            minVals.push(key)
        }
    }
    return minVals[0]
};
var licensePlate = "1s3 456";
var words = ["looks","pest","stew","show"];
console.log(shortestCompletingWord(licensePlate, words));
```

# 754. 到达终点数字【1/1】

在一根无限长的数轴上，你站在0的位置。终点在target的位置。

每次你可以选择向左或向右移动。第 n 次移动（从 1 开始），可以走 n 步。

返回到达终点需要的最小移动次数。

**示例 1:**

> 输入: target = 3
> 输出: 2
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 3 。

**示例 2:**

> 输入: target = 2
> 输出: 3
解释:
第一次移动，从 0 到 1 。
第二次移动，从 1 到 -1 。
第三次移动，从 -1 到 2 。

**注意:**

target是在[-10^9, 10^9]范围中的非零整数。

**Answer**

**思路：**

首先， 由于坐标轴是对称的，往左往右走的几率相等，因此可以只考虑右半轴。先递推一下可以知道:


|步数|        能到达的位置|
|---|---|
|1:|          1|
|2:|          3, 1|
|3:|          6, 4, 2, 0|
|4:|          10, 8, 6, 4, 0|
|5:|          15, 13, 11, 9, 7, 5, 3, 1|
|6:|          21, 19, 17, ...3, 1|
|n:|          (1+n)*n/2, ...|


可以看出来，每一步能到达的最大位置是上一步最大位置加上步数，而每一步所能达到的位置之间间隔都为2。
记f(n)为第n步能到达的位置，那么有：

```js
max(f(n)) = max(f(n-1)) + n
f(n) = [max(f(n)),  max(f(n)) - 2, max(f(n)) - 4, ....]
```

如果 target 可以在第 n 步达到，那么 target 一定小于等于 max(f(n)) 且 max(f(n)) 与 taget 同奇同偶。

```js
/**
 * @param {number} target
 * @return {number}
 */
var reachNumber = function(target) {
    let sum = 0;
    let n = 0;
    target = Math.abs(target);
    while(sum < target || (target + sum) % 2 !== 0) {
        n++;
        sum += n;
    }
    return n
};
var target = 2;
console.log(reachNumber(target));
```


# 762. 二进制表示中质数个计算置位

给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。

（注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。）

**示例 1:**

> 输入: L = 6, R = 10
> 输出: 4
解释:
6 -> 110 (2 个计算置位，2 是质数)
7 -> 111 (3 个计算置位，3 是质数)
9 -> 1001 (2 个计算置位，2 是质数)
10-> 1010 (2 个计算置位，2 是质数)

**示例 2:**

> 输入: L = 10, R = 15
> 输出: 5
解释:
10 -> 1010 (2 个计算置位, 2 是质数)
11 -> 1011 (3 个计算置位, 3 是质数)
12 -> 1100 (2 个计算置位, 2 是质数)
13 -> 1101 (3 个计算置位, 3 是质数)
14 -> 1110 (3 个计算置位, 3 是质数)
15 -> 1111 (4 个计算置位, 4 不是质数)

**注意:**

1. L, R 是 L <= R 且在 [1, 10^6] 中的整数。
2. R - L 的最大值为 10000。

**Answer**

```js
/**
 * @param {number} L
 * @param {number} R
 * @return {number}
 */
var countPrimeSetBits = function(L, R) {
    // 存储二进制中1的个数
    let arr = []
    for (let i = L; i <= R; i++) {
        arr.push(i.toString(2).replace(/0/g, '').length)
    }
    // 判断一个数是否为质数
    let isPrime = function(num) {
        if (num === 1) {
            return false;
        }
        for (let i = 2; i < num; i++) {
            if (num % i === 0) {
                return false;
            }
        }
        return true
    }
    //质数个数
    let count = 0;
    for (let item of arr) {
        if (isPrime(item)) {
            count++
        }
    }
    return count
};
var L = 6;
var R = 10;
console.log(countPrimeSetBits(L, R));
```

# 766. 托普利茨矩阵

如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。

给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。

**示例 1:**

> 输入: 
matrix = [
  [1,2,3,4],
  [5,1,2,3],
  [9,5,1,2]
]
> 输出: True
解释:
在上述矩阵中, 其对角线为:
"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]"。
各条对角线上的所有元素均相同, 因此答案是True。

**示例 2:**

> 输入:
matrix = [
  [1,2],
  [2,2]
]
> 输出: False
解释: 
对角线"[1, 2]"上的元素不同。

**说明:**

1. matrix 是一个包含整数的二维数组。
2. matrix 的行数和列数均在 [1, 20]范围内。
3. matrix[i][j] 包含的整数在 [0, 99]范围内。

**进阶:**

1. 如果矩阵存储在磁盘上，并且磁盘内存是有限的，因此一次最多只能将一行矩阵加载到内存中，该怎么办？
2. 如果矩阵太大以至于只能一次将部分行加载到内存中，该怎么办？


**Answer**

判断每个元素 arr[i][j] 【i>=1&&j>=1】是否和这个元素左上角的元素 arr[i-1][j-1] 相等

```js
/**
 * @param {number[][]} matrix
 * @return {boolean}
 */
var isToeplitzMatrix = function(matrix) {
    let row = matrix.length; 
    let col = matrix[0].length;
    for (let i = 1; i < row; i++) {
        for (let j = 1; j < col; j++) {
            if (matrix[i][j] != matrix[i-1][j-1]) {
                return false
            }
        }
    }
    return true
};
var matrix =  [
  [1,2,3,4],
  [5,1,2,3],
  [9,5,1,2]
];
console.log(isToeplitzMatrix(matrix));
```

# 771. 宝石与石头

给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。

J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。

**示例 1:**

> 输入: J = "aA", S = "aAAbbbb"
> 输出: 3

**示例 2:**

> 输入: J = "z", S = "ZZ"
> 输出: 0

**注意:**

- S 和 J 最多含有50个字母。
- J 中的字符不重复。


**Answer**

*法一：暴力双循环*

```js
/**
 * @param {string} J
 * @param {string} S
 * @return {number}
 */
var numJewelsInStones = function(J, S) {
    let count = 0;
    for(let i = 0; i < S.length; i++) {
        let index = i;
        for(let j = 0; j < J.length; j++) {
          if (S[i] === J[j]) {
              count++;
              i--;
              S = S.slice(0, index) + S.slice(index+1, S.length)
          }
        }
    }
    return count
};
var J = "aA";
var S = "aAAbbbb";
console.log(numJewelsInStones(J, S));
```

*法二：正则*

```js
var numJewelsInStones2 = function(J, S) {
    let len = S.length;
    for(let i = 0; i < J.length; i++) {
        let pat = new RegExp(J[i], 'g');
        S = S.replace(pat, '')
    }
    return len - S.length;
};
console.log(numJewelsInStones2(J, S));
```

*法三：正则*

```js
var numJewelsInStones3 = function(J, S) {
    let len = S.length;
    let SS = '[' + J + ']';
    let pat = new RegExp(SS, 'g');
    S = S.replace(pat, '')
    return len - S.length;
};
console.log(numJewelsInStones3(J, S));
```

*法四：数组 filter() 方法*

```js
var numJewelsInStones4 = function(J, S) {
    let jArr = J.split('');
    let sArr = S.split('');
    let JS = sArr.filter((item) => {
        return jArr.includes(item)
    })
    return JS.length
};
console.log(numJewelsInStones4(J, S));
```

*法五：借助Set数据集*

```js
var numJewelsInStones5 = function(J, S) {
    let set = new Set(J.split(''));
    let count = 0;
    for (let item of S) {
      if(set.has(item)) {
        count++
      }
    }
    return count
};
console.log(numJewelsInStones5(J, S));
```

## 784. 字母大小写全排列(未做)


给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。

**示例:**

> 输入: S = "a1b2"
> 输出: ["a1b2", "a1B2", "A1b2", "A1B2"]

> 输入: S = "3z4"
> 输出: ["3z4", "3Z4"]

> 输入: S = "12345"
> 输出: ["12345"]

**注意：**

- S 的长度不超过12。
- S 仅由数字和字母组成。



# 788. 旋转数字

我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。

如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。

现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？

**示例:**

> 输入: 10
> 输出: 4
解释: 
在[1, 10]中有四个好数： 2, 5, 6, 9。
注意 1 和 10 不是好数, 因为他们在旋转之后不变。

**注意:**

- N 的取值范围是 [1, 10000]。

**Answer**

*法一*

```js
/**
 * @param {number} N
 * @return {number}
 */
var rotatedDigits = function(N) {
    let goodNum = '2569';
    let count = 0;
    for(let i = 1; i <= N; i++) {
        let str = i.toString();
        if (str.indexOf('3') >= 0 || str.indexOf('4') >= 0 || str.indexOf('7') >= 0) {
            continue
        }
        for (let j = 0; j < str.length; j++) {
            if (goodNum.indexOf(str[[j]]) !== -1) {
                count++
                break
            }
        }
    }
    return count
};
var N = 857;
console.log(rotatedDigits(N));
```

*法二：正则*

```js
var rotatedDigits2 = function(N) {
    // 检测N是否含有3、4、7这三个数中的任意一个
    let pat1 = /[347]+/;
    // 检测N是否全部为0、1、8这三个数组成
    let pat2 = /^[018]+$/;
    let count1 = 0;
    let count2 = 0;
    for(let i = 1; i <= N; i++) {
        if (pat1.test(i)) {
        	count1++;
        }
        if (pat2.test(i)) {
        	count2++
        }
    }
    return N - count1 - count2
};
console.log(rotatedDigits2(N));
```

*法三:正则*

```js
var rotatedDigits = function(N) {
  let ans = 0;
  let reg1 = new RegExp("3|4|7");
  let reg2 = new RegExp("2|5|6|9");
  for(let i=1; i<= N; i++) {
    if(!reg1.test(i) && reg2.test(i)) {
      ans++;
    }
  }
  return ans;
};
```

# 796. 旋转字符串

给定两个字符串, A 和 B。

A 的旋转操作就是将 A 最左边的字符移动到最右边。 例如, 若 A = 'abcde'，在移动一次之后结果就是'bcdea' 。如果在若干次旋转操作之后，A 能变成B，那么返回True。

**示例 1:**

> 输入: A = 'abcde', B = 'cdeab'
> 输出: true

**示例 2:**

> 输入: A = 'abcde', B = 'abced'
> 输出: false

**注意：**

- A 和 B 长度不超过 100。

**Answer**

*法一*

```js
/**
 * @param {string} A
 * @param {string} B
 * @return {boolean}
 */
var rotateString = function(A, B) {
    if (A === '' && B === '') {
        return true
    }
    let len = A.length - 1;
    while(len > 0) {
        let A1 = A.slice(0,1)
        let A2 = A.slice(1,A.length)
        A = A2+ A1;
        if (A === B) {
            return true;
        }
        len--
    }
    return false
};
```

*法二*

```js
var rotateString = function(A, B) {
    if (A === B) {
        return true
    }
    if (A.length !== B.length) {
        return false
    }
    let len = A.length - 1;
    while(len > 0) {
        A = A.substr(1) + A[0];
        if (A === B) {
            return true;
        }
        len--
    }
    return false
};

var A = 'abcde';
var B = 'abced';
console.log(rotateString(A, B));
```

*法三*

思路：只需比较一下两个字符串的长度，然后判断A + A中是否存在B就ok，因为A + A中已经包含了所有可能的移动情况

```js
var rotateString2 = function(A, B) {
    if (A.length === B.length && (A + A).includes(B)) {
        return true
    }
    return false
};
```

# 811. 子域名访问计数

一个网站域名，如"discuss.leetcode.com"，包含了多个子域名。作为顶级域名，常用的有"com"，下一级则有"leetcode.com"，最低的一级为"discuss.leetcode.com"。当我们访问域名"discuss.leetcode.com"时，也同时访问了其父域名"leetcode.com"以及顶级域名 "com"。

给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如："9001 discuss.leetcode.com"。

接下来会给出一组访问次数和域名组合的列表cpdomains 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。

**示例 1:**

> 输入: 
["9001 discuss.leetcode.com"]
> 输出: 
["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"]
说明: 
例子中仅包含一个网站域名："discuss.leetcode.com"。按照前文假设，子域名"leetcode.com"和"com"都会被访问，所以它们都被访问了9001次。

**示例 2**

> 输入: 
["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]
> 输出: 
["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]

**说明: **

按照假设，会访问"google.mail.com" 900次，"yahoo.com" 50次，"intel.mail.com" 1次，"wiki.org" 5次。
而对于父域名，会访问"mail.com" 900+1 = 901次，"com" 900 + 50 + 1 = 951次，和 "org" 5 次。

**注意事项：**

- cpdomains 的长度小于 100。
- 每个域名的长度小于100。
- 每个域名地址包含一个或两个"."符号。
- 输入中任意一个域名的访问次数都小于10000。

**Answer**

```js
/**
 * @param {string[]} cpdomains
 * @return {string[]}
 */
var subdomainVisits = function(cpdomains) {
    let map = new Map();
    for (let i = 0; i < cpdomains.length; i++) {
        let [num, url] = cpdomains[i].split(/\s+/);
        var items = [url];
        for (let j = 0; j < url.length; j++) {
            if (url[j] === '.') {
                items.push(url.substr(j+1))
            }
        }
        items.forEach((item) => {
            if (!map.has(item)) {
                map.set(item, +num)
            } else {
                map.set(item, map.get(item) + +num)
            }
        })
    }
    let res = [];
    for (let [key, val] of map) {
        res.push(`${val} ${key}`)
    }
    return res
};
var cpdomains = ["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"];
console.log(subdomainVisits(cpdomains));
```

```js
var subdomainVisits = function(cpdomains) {
    let map = new Map()
    let res = []
    for(let i = 0; i < cpdomains.length; i++) {
        let [num, url] = cpdomains[i].split(' ')
        
        while(url.includes('.')){
            if(map.has(url)){
                map.set(url, (Number(map.get(url)) + Number(num)))
            } else {
                map.set(url, num)
            }            
            url = url.slice(url.indexOf('.') + 1)
        }
        
        if(map.has(url)){
            map.set(url, (Number(map.get(url)) + Number(num)))
        } else {
            map.set(url, num)
        }
    }
    map.forEach((value, key) => {
        res.push(`${value} ${key}`)
    })
    return res
};
```

# 819. 最常见的单词

给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。题目保证至少有一个词不在禁用列表中，而且答案唯一。

禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。

**示例：**

> 输入: 
paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."
banned = ["hit"]
> 输出: "ball"
解释: 
"hit" 出现了3次，但它是一个禁用的单词。
"ball" 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。 

注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 "ball,"）， 
"hit"不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。
 
**说明：**

- 1 <= 段落长度 <= 1000.
- 1 <= 禁用单词个数 <= 100.
- 1 <= 禁用单词长度 <= 10.
- 答案是唯一的, 且都是小写字母 (即使在 paragraph 里是大写的，即使是一些特定的名词，答案都是小写的。)
- paragraph 只包含字母、空格和下列标点符号!?',;.
- 不存在没有连字符或者带有连字符的单词。
- 单词里只包含字母，不会出现省略号或者其他标点符号。


**Answer**

```js
/**
 * @param {string} paragraph
 * @param {string[]} banned
 * @return {string}
 */
var mostCommonWord = function(paragraph, banned) {
    let paragraphArr = paragraph.toLowerCase().replace(/[!?',;\.]/g,' ').split(/[\s]+/);
    let map = new Map();
    let len = paragraphArr.length
    for (let i = 0; i < len; i++) {
        if(banned.includes(paragraphArr[i]) || paragraphArr[i] === '') {
            continue
        }
        if (!map.has(paragraphArr[i])) {
            map.set(paragraphArr[i], 1)
        } else {
            map.set(paragraphArr[i], map.get(paragraphArr[i]) + 1)
        }
    }
    let maxCount = Math.max.apply(Math, [...map.values()]);
    let res = '';
    map.forEach((val, key) => {
        if (val === maxCount) {
            res = key
            return
        }
    })
    return res
};

var paragraph = "a."
var banned = []
console.log(mostCommonWord(paragraph, banned));
```

# 821. 字符的最短距离

给定一个字符串 S 和一个字符 C。返回一个代表字符串 S 中每个字符到字符串 S 中的字符 C 的最短距离的数组。

**示例 1:**

> 输入: S = "loveleetcode", C = 'e'
> 输出: [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0]

**说明:**

1. 字符串 S 的长度范围为 [1, 10000]。
2. C 是一个单字符，且保证是字符串 S 里的字符。
3. S 和 C 中的所有字母均为小写字母。

**Answer**

*法一：双循环*

```js
/**
 * @param {string} S
 * @param {character} C
 * @return {number[]}
 */
var shortestToChar = function(S, C) {
    let len = S.length;
    let cArr = [];
    let res = [];
    for (let i = 0; i < len; i++) {
        if (S[i] === C) {
            cArr.push(i)
        }
    }
    for (let i = 0; i < len; i++) {
        let distance = Math.abs(i - cArr[0]);
        for (let j = 0; j < cArr.length; j++) {
            if (distance > Math.abs(i - cArr[j])) {
                distance = Math.abs(i - cArr[j])
            }
        }
        res.push(distance)
    }
    return res;
};
var S = "loveleetcode";
var C = 'e';
console.log(shortestToChar(S, C));
```

*法二： 双指针*

```js
var shortestToChar2 = function(S, C) {
    let len = S.length;
    let res = [];
    // 先找到前两个 C 出现的位置
    let left = S.indexOf(C);
    let right = S.indexOf(C, 1 + left);
    for (let i = 0; i < len; i++) {
        // 计算与左指针的距离
        res[i] = Math.abs(left - i);
        if (right != -1) {
            // 如果右指针存在,取较小的距离
            res[i] = Math.min(res[i], right - i) 
            // i 走到右指针则左右指针往下一个
            if (i == right) {
                res[i] = 0;
                left = right;
                right = S.indexOf(C, right + 1)
            }
        }
    }
    return res;
};
```

# 824. 山羊拉丁文

给定一个由空格分割单词的句子 S。每个单词只包含大写或小写字母。

我们要将句子转换为 “Goat Latin”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。

山羊拉丁文的规则如下：

如果单词以元音开头（a, e, i, o, u），在单词后添加"ma"。
例如，单词"apple"变为"applema"。

如果单词以辅音字母开头（即非元音字母），移除第一个字符并将它放到末尾，之后再添加"ma"。
例如，单词"goat"变为"oatgma"。

根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从1开始。
例如，在第一个单词后添加"a"，在第二个单词后添加"aa"，以此类推。
返回将 S 转换为山羊拉丁文后的句子。

**示例 1:**

> 输入: "I speak Goat Latin"
> 输出: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"

**示例 2:**

> 输入: "The quick brown fox jumped over the lazy dog"
> 输出: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"

**说明:**

- S 中仅包含大小写字母和空格。单词间有且仅有一个空格。
- 1 <= S.length <= 150。

**Answer**

```js
/**
 * @param {string} S
 * @return {string}
 */
var toGoatLatin = function(S) {
    let pat = /^[aeiou]/i;
    let sArr = S.split(' ');
    res = '';
    for (let i = 0; i < sArr.length; i++) {
        if (!pat.test(sArr[i])) {
            sArr[i] = sArr[i].substr(1) + sArr[i][0] 
        }
        res += sArr[i] + 'ma' + 'a'.repeat(i+1) + ' '
    }
    return res.replace(/[\s]$/, '')
};
var S = "I speak Goat Latin";
console.log(toGoatLatin(S));
```

# 830. 较大分组的位置

在一个由小写字母构成的字符串 S 中，包含由一些连续的相同字符所构成的分组。

例如，在字符串 S = "abbxxxxzyy" 中，就含有 "a", "bb", "xxxx", "z" 和 "yy" 这样的一些分组。

我们称所有包含大于或等于三个连续字符的分组为较大分组。找到每一个较大分组的起始和终止位置。

最终结果按照字典顺序输出。

**示例 1:**

> 输入: "abbxxxxzzy"
> 输出: [[3,6]]
解释: "xxxx" 是一个起始于 3 且终止于 6 的较大分组。

**示例 2:**

> 输入: "abc"
> 输出: []
解释: "a","b" 和 "c" 均不是符合要求的较大分组。

**示例 3:**

> 输入: "abcdddeeeeaabbbcd"
> 输出: [[3,5],[6,9],[12,14]]

说明:  1 <= S.length <= 1000

**Answer**

*法一：双指针*

```js
/**
 * @param {string} S
 * @return {number[][]}
 */
var largeGroupPositions = function(S) {
    let left = 0;
    let right = 1;
    let arr = [];
    let len = S.length;
    while(right < len) {
        if (S[left] === S[right]) {
            right++;
        } else {
            if (right - left >= 3) {
                arr.push([left, right-1])
            }
            left = right;
        }
    }
    if (right - left >= 3) {
        arr.push([left, right-1])
    }
    return arr
};
var S = "abcdddeeeeaabbbcd";
console.log(largeGroupPositions(S));
```

*法二：正则*

```js
var largeGroupPositions2 = function(S) {
    const pat = /(\w)\1{2,}/g
    let arr = [];
    let item;
    while((item = pat.exec(S)) !== null) {
        arr.push([item.index, item.index + item[0].length - 1])
    }
    return arr
};
```

# 832. 翻转图像

给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。

水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。

反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。

**示例 1:**

输入: [[1,1,0],[1,0,1],[0,0,0]]
输出: [[1,0,0],[0,1,0],[1,1,1]]
解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]；
     然后反转图片: [[1,0,0],[0,1,0],[1,1,1]]

**示例 2:**

输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]
输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]
解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]；
     然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]

**说明:**

- 1 <= A.length = A[0].length <= 20
- 0 <= A[i][j] <= 1

**Answer**

*法一*

```js
/**
 * @param {number[][]} A
 * @return {number[][]}
 */
var flipAndInvertImage = function(A) {
    let res = []
    for (let i = 0; i < A.length; i++) {
        let len = A[i].length;
        let halfLen = parseInt(len / 2);
        let arr = [];
        for (let j = 0; j < halfLen; j++) {
            let temp = A[i][j];
            A[i][j] = A[i][len-j-1];
            A[i][len-j-1] = temp;
        }
        for (let j = 0; j < len; j++) {
            if (A[i][j] === 0) {
                arr.push(1)
            } else {
                arr.push(0)
            }
        }
        res.push(arr)
    }
    return res
};
var A = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]];
console.log(flipAndInvertImage(A));
```

*法二*

```js
var flipAndInvertImage = function(A) {
    return A.map((item) => {
        return item.reverse().map((num) => {
            return num === 1 ? 0 : 1
        })
    });
};
console.log(flipAndInvertImage2(A));
```

# 836. 矩形重叠

矩形以列表 [x1, y1, x2, y2] 的形式表示，其中 (x1, y1) 为左下角的坐标，(x2, y2) 是右上角的坐标。

如果相交的面积为正，则称两矩形重叠。需要明确的是，只在角或边接触的两个矩形不构成重叠。

给出两个矩形，判断它们是否重叠并返回结果。

**示例 1：**

> 输入：rec1 = [0,0,2,2], rec2 = [1,1,3,3]
> 输出：true

**示例 2：**

> 输入：rec1 = [0,0,1,1], rec2 = [1,0,2,1]
> 输出：false

**说明：**

1. 两个矩形 rec1 和 rec2 都以含有四个整数的列表的形式给出。
2. 矩形中的所有坐标都处于 -10^9 和 10^9 之间。

**Answer**

rec1 与 rec2 不重叠的情况有以下4种：

rec1 = [x1,y1,x2,y2]
rec2 = [a1,b1,a2,b2]

rec1在rec2左边，不重叠时，rec1右上角的点[x2,y2] 小于rec2左下角的点[a1,b1]

rec1在rec2右边，不重叠时，rec1左下角的点[x1,y1] 大于rec2右下角的点[a2,b2]


```js
/**
 * @param {number[]} rec1
 * @param {number[]} rec2
 * @return {boolean}
 */
var isRectangleOverlap = function(rec1, rec2) {
    
    return !(rec2[0] >= rec1[2] || rec2[1] >= rec1[3] || rec2[2] <= rec1[0] || rec2[3] <= rec1[1]);
    
};
```

```js
var isRectangleOverlap = function(rec1, rec2) {
    let x1 = Math.max(rec1[0],rec2[0]);
    let x2 = Math.min(rec1[2],rec2[2]);
    let y1 = Math.max(rec1[1],rec2[1]);    
    let y2 = Math.min(rec1[3],rec2[3]);    
    return x1 < x2 && y1 < y2;
};


var rec1 = [0,0,1,1];
var rec2 = [1,0,2,1];
console.log(isRectangleOverlap(rec1, rec2));
```

# 840. 矩阵中的幻方

3 x 3 的幻方是一个填充有从 1 到 9 的不同数字的 3 x 3 矩阵，其中每行，每列以及两条对角线上的各数之和都相等。

给定一个由整数组成的 grid，其中有多少个 3 × 3 的 “幻方” 子矩阵？（每个子矩阵都是连续的）。

**示例：**

> 输入: [[4,3,8,4],
      [9,5,1,9],
      [2,7,6,2]]
> 输出: 1
解释: 
下面的子矩阵是一个 3 x 3 的幻方：
438
951
276

而这一个不是：
384
519
762

总的来说，在本示例所给定的矩阵中只有一个 3 x 3 的幻方子矩阵。

**提示:**

1. 1 <= grid.length <= 10
2. 1 <= grid[0].length <= 10
3. 0 <= grid[i][j] <= 15

**Answer**

```js
/**
 * @param {number[]} rec1
 * @param {number[]} rec2
 * @return {boolean}
 */
var numMagicSquaresInside = function(grid) {
    let huanfang = [
	    '[8,1,6,3,5,7,4,9,2]',
	    '[6,1,8,7,5,3,2,9,4]',
	    '[4,9,2,3,5,7,8,1,6]',
	    '[2,9,4,7,5,3,6,1,8]',
	    '[6,7,2,1,5,9,8,3,4]',
	    '[8,3,4,1,5,9,6,7,2]',
	    '[2,7,6,9,5,1,4,3,8]',
	    '[4,3,8,9,5,1,2,7,6]'
    ]
    let count = 0;
    for (let i = 0; i < grid.length - 2; i++) {
    	for (j = 0; j < grid[0].length - 2; j++) {
    		let temp = [];
    		temp.push(grid[i][j])
    		temp.push(grid[i][j+1])
    		temp.push(grid[i][j+2])
    		temp.push(grid[i+1][j])
    		temp.push(grid[i+1][j+1])
    		temp.push(grid[i+1][j+2])
    		temp.push(grid[i+2][j])
    		temp.push(grid[i+2][j+1])
    		temp.push(grid[i+2][j+2])
    		temp = '[' + temp + ']';
    		if (huanfang.includes(temp)) {
    			count++
    		}
    	}
    }
    return count
};

var grid = [
    [4,3,8,4],
    [9,5,1,9],
    [2,7,6,2]
];

console.log(numMagicSquaresInside(grid));
```

# 844. 比较含退格的字符串

给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。

**示例 1：**

> 输入：S = "ab#c", T = "ad#c"
> 输出：true
解释：S 和 T 都会变成 “ac”。

**示例 2：**

> 输入：S = "ab##", T = "c#d#"
> 输出：true
解释：S 和 T 都会变成 “”。

**示例 3：**

> 输入：S = "a##c", T = "#a#c"
> 输出：true
解释：S 和 T 都会变成 “c”。

**示例 4：**

> 输入：S = "a#c", T = "b"
> 输出：false
解释：S 会变成 “c”，但 T 仍然是 “b”。
 

**提示：**

1. 1 <= S.length <= 200
2. 1 <= T.length <= 200
3. S 和 T 只含有小写字母以及字符 '#'。

**Answer**

使用正则表达式

```js
/**
 * @param {string} S
 * @param {string} T
 * @return {boolean}
 */
var backspaceCompare = function(S, T) {
    let pat = /([\w]#)/;
    let pat2 = /^#+/;
    while(/#/.test(S)) {
        S = S.replace(pat, '').replace(pat2, '')
    }
    while(/#/.test(T)) {
        T = T.replace(pat, '').replace(pat2, '')
    }
    return S === T
};
var S = "a##c";
var T = "#a#c";
console.log(backspaceCompare(S, T));
```


```js
var backspaceCompare2 = function(S, T) {
    let pat = /.?\#/;
    while(/#/.test(S)) {
        S = S.replace(pat, '')
    }
    while(/#/.test(T)) {
        T = T.replace(pat, '')
    }
    return S === T
};
console.log(backspaceCompare2(S, T));
```

# 849. 到最近的人的最大距离

在一排座位（ seats）中，1 代表有人坐在座位上，0 代表座位上是空的。

至少有一个空座位，且至少有一人坐在座位上。

亚历克斯希望坐在一个能够使他与离他最近的人之间的距离达到最大化的座位上。

返回他到离他最近的人的最大距离。

**示例 1：**

> 输入：[1,0,0,0,1,0,1]
> 输出：2
解释：
如果亚历克斯坐在第二个空位（seats[2]）上，他到离他最近的人的距离为 2 。
如果亚历克斯坐在其它任何一个空位上，他到离他最近的人的距离为 1 。
因此，他到离他最近的人的最大距离是 2 。 

**示例 2：**

> 输入：[1,0,0,0]
> 输出：3
解释： 
如果亚历克斯坐在最后一个座位上，他离最近的人有 3 个座位远。
这是可能的最大距离，所以答案是 3 。

**提示：**

1. 1 <= seats.length <= 20000
2. seats 中只含有 0 和 1，至少有一个 0，且至少有一个 1。

**Answer**

*法一：双指针*

```js
/**
 * @param {number[]} seats
 * @return {number}
 */
var maxDistToClosest = function(seats) {

    let left = seats.indexOf(1);
    let right = seats.indexOf(1, left);
    let arr = [left];
    let len = seats.length;

    for (let i = 0; i < len; i++) {
        if (seats[i] === 1) {
            left = i;
            right = seats.indexOf(1, left+1); 
            if (right !== -1) {
                arr.push(Math.floor((right-left) / 2))
            } else {
                arr.push(len-left-1)
            }
        } 
    }

    return Math.max(...arr)
};
//var seats = [1,0,0,0,1,0,1];
//var seats = [1,0,0,0];
var seats = [0,0,0,1];
//var seats = [0,1];
//var seats = [0,1,1,1,0,0,1,0,0];
console.log(maxDistToClosest(seats));
```

*法二*

处理这三种情况就可以

•	座位为001时 
•	座位为101时 
•	座位为100时 

```js
var maxDistToClosest2 = function(seats) {

    let arr = seats.join('').split('1').map((item) => item.length);
    let leftMax = arr.shift();
    let rightMax = arr.pop();
    let zeroMax = Math.max(...arr);
    let centerMax = Math.ceil(zeroMax / 2)

    return Math.max(leftMax, rightMax, centerMax)
};
```

# 852. 山脉数组的峰顶索引

我们把符合下列属性的数组 A 称作山脉：

A.length >= 3
存在 0 < i < A.length - 1 使得A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]
给定一个确定为山脉的数组，返回任何满足 A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1] 的 i 的值。

**示例 1：**

> 输入：[0,1,0]
> 输出：1

**示例 2：**

> 输入：[0,2,1,0]
> 输出：1
 
**提示：**

1. 3 <= A.length <= 10000
2. 0 <= A[i] <= 10^6
3. A 是如上定义的山脉

**Answer**

```js
/**
 * @param {number[]} A
 * @return {number}
 */
var peakIndexInMountainArray = function(A) {
    let maxVal = Math.max(...A);
    let maxIndex = A.indexOf(maxVal);
    return maxIndex
};
var A = [0,2,1,0];
console.log(peakIndexInMountainArray(A));
```

# 859. 亲密字符串

给定两个由小写字母构成的字符串 A 和 B ，只要我们可以通过交换 A 中的两个字母得到与 B 相等的结果，就返回 true ；否则返回 false 。

**示例 1：**

> 输入： A = "ab", B = "ba"
> 输出： true

**示例 2：**

> 输入： A = "ab", B = "ab"
> 输出： false

**示例 3:**

> 输入： A = "aa", B = "aa"
> 输出： true

**示例 4：**

> 输入： A = "aaaaaaabc", B = "aaaaaaacb"
> 输出： true

**示例 5：**

> 输入： A = "", B = "aa"
> 输出： false

**提示：**

1. 0 <= A.length <= 20000
2. 0 <= B.length <= 20000
3. A 和 B 仅由小写字母构成。


**Answer**

1.	字符串长度不相等, 直接返回false
2.	字符串相等的时候, 只要有重复的元素就返回true
3.	A, B字符串有不相等的两个地方, 需要查看它们交换后是否相等即可.


```js
/**
 * @param {string} A
 * @param {string} B
 * @return {boolean}
 */
var buddyStrings = function(A, B) {
    let aLen = A.length;
    let bLen = B.length;
    if (aLen !== bLen) {
    	return false
    }
    if (A === B) {
    	return new Set(A).size !== A.length
    }
    let start;
    let end;
    for (let i = 0; i < aLen; i++) {
    	if (A[i] !== B[i]) {
            start = i;
            break;
    	}
    }
    for (let i = aLen-1; i >= 0; i--) {
    	if (A[i] !== B[i]) {
            end = i;
            break;
    	}
    }
    let arr = A.split('');
    [arr[start],arr[end]] = [arr[end],arr[start]]
    return arr.join('') === B
};
var A = "abc";
var B = "acd";
console.log(buddyStrings(A, B));
```

# 860. 柠檬水找零

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。

顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

**示例 1：**

> 输入：[5,5,5,10,20]
> 输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。

**示例 2：**

> 输入：[5,5,10]
> 输出：true

**示例 3：**

> 输入：[10,10]
> 输出：false

**示例 4：**

> 输入：[5,5,10,10,20]
> 输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。
 

**提示：**

- 0 <= bills.length <= 10000
- bills[i] 不是 5 就是 10 或是 20 

**Answer**

思路：

- 当收到5时
    + 店家手里的5++

- 当收到10时
    + 优先匹配一张5如有返回true
        - 店家手里的5--，10++
        - 如没有返回false

- 当收到20时
    + 优先匹配店家手里的一张10和一张5，如有返回true
        - 店家手里的10--
        - 店家手里的5--
    + 如没有重新匹配3张5，如有返回true
        - 店家手里的5-=3
    + 如都没有返回false



```js
/**
 * @param {number[]} bills
 * @return {boolean}
 */
var lemonadeChange = function(bills) {
    let count5 = 0;
    let count10 = 0;
    for (let i = 0; i < bills.length; i++) {
        if (bills[i] === 5) {
            count5++
        } else if (bills[i] === 10) {
            if (count5 > 0) {
                count5--;
            } else {
                return false
            }
            count10++;
        } else {
            if (count10 > 0) {
                count10--
                count5--
            } else {
                count5 -= 3
            }
        }
        if (count5 < 0) {
            return false
        }
    }
    return true;
};
var bills = [5,5,5,10,20];
console.log(lemonadeChange(bills));
```

# 867. 转置矩阵

给定一个矩阵 A， 返回 A 的转置矩阵。

矩阵的转置是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。

**示例 1：**

> 输入：[[1,2,3],[4,5,6],[7,8,9]]
> 输出：[[1,4,7],[2,5,8],[3,6,9]]

**示例 2：**

> 输入：[[1,2,3],[4,5,6]]
> 输出：[[1,4],[2,5],[3,6]]

**提示：**

1. 1 <= A.length <= 1000
2. 1 <= A[0].length <= 1000

**Answer**

```js
/**
 * @param {number[][]} A
 * @return {number[][]}
 */
var transpose = function(A) {
    let arr = []
    for (let j = 0; j < A[0].length; j++) {
        let temp = [];
        for (let i = 0; i < A.length; i++) {
            temp.push(A[i][j])
        }
        arr.push(temp)
    }
    return arr
};
var A = [[1,2,3],[4,5,6],[7,8,9]];
console.log(transpose(A));
```

# 868. 二进制间距

给定一个正整数 N，找到并返回 N 的二进制表示中两个连续的 1 之间的最长距离。 

如果没有两个连续的 1，返回 0 。

**示例 1：**

> 输入：22
> 输出：2
解释：
22 的二进制是 0b10110 。
在 22 的二进制表示中，有三个 1，组成两对连续的 1 。
第一对连续的 1 中，两个 1 之间的距离为 2 。
第二对连续的 1 中，两个 1 之间的距离为 1 。
答案取两个距离之中最大的，也就是 2 。

**示例 2：**

> 输入：5
> 输出：2
解释：
5 的二进制是 0b101 。

**示例 3：**

> 输入：6
> 输出：1
解释：
6 的二进制是 0b110 。

**示例 4：**

> 输入：8
> 输出：0
解释：
8 的二进制是 0b1000 。
在 8 的二进制表示中没有连续的 1，所以返回 0 。

**提示：**

1 <= N <= 10^9

**Answer**

*法一:双指针*

```js
/**
 * @param {number} N
 * @return {number}
 */
var binaryGap = function(N) {
    let nTo2 = N.toString(2);
    let left = nTo2.indexOf('1');
    let right = nTo2.indexOf('1', left+1);
    let max = 0;
    for (let i = left+1; i < nTo2.length; i++) {
        if (nTo2[i] == 1) {
            max = Math.max(max, right-left)
            left = i;
            right = nTo2.indexOf('1', left+1);
        }
    }
    return max
};
var N = 22;
console.log(binaryGap(N));
```

*法二：正则*

```js
var binaryGap2 = function(N) {
    let bi = N.toString(2);
    let max = 0;
    // 匹配连续的0
    let arr = bi.match(/(?<=1)0*(?=1)/g);

    if (arr == null) return 0;   
    for(let i = 0; i < arr.length; i++){
        if(arr[i].length+1 > max)
            max = arr[i].length + 1;     
    }
    return arr;
    return max;
};
```

[?<=](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions?from=singlemessage)

# 883. 三维形体投影面积

在 N * N 的网格中，我们放置了一些与 x，y，z 三轴对齐的 1 * 1 * 1 立方体。

每个值 v = grid[i][j] 表示 v 个正方体叠放在单元格 (i, j) 上。

现在，我们查看这些立方体在 xy、yz 和 zx 平面上的投影。

投影就像影子，将三维形体映射到一个二维平面上。

在这里，从顶部、前面和侧面看立方体时，我们会看到“影子”。

返回所有三个投影的总面积。

**示例 1：**

> 输入：[[2]]
> 输出：5

**示例 2：**

> 输入：[[1,2],[3,4]]
> 输出：17
解释：
这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。

![](https://s3-lc-upload.s3.amazonaws.com/uploads/2018/08/02/shadow.png)

**示例 3：**

> 输入：[[1,0],[0,2]]
> 输出：8

**示例 4：**

> 输入：[[1,1,1],[1,0,1],[1,1,1]]
> 输出：14

**示例 5：**

> 输入：[[2,2,2],[2,1,2],[2,2,2]]
> 输出：21
 
**提示：**

- 1 <= grid.length = grid[0].length <= 50
- 0 <= grid[i][j] <= 50

**Answer**

题目给的是方块，grid.length = grid[0].length

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var projectionArea = function(grid) {
    let left = 0;
    let right = 0;
    let up = 0;
    let n = grid.length;
    for (let i = 0; i < n; i++) {
        left += Math.max(...grid[i])
        let temp = []
        for (let j = 0; j < n; j++) {
            if (grid[i][j] !== 0) {
                up++
            }
            temp.push(grid[j][i])
        }
        right += Math.max(...temp)
    } 
    return left + right + up
};
var grid = [[2,2,2],[2,1,2],[2,2,2]];
console.log(projectionArea(grid));
```

# 884. 两句话中的不常见单词

给定两个句子 A 和 B 。 （句子是一串由空格分隔的单词。每个单词仅由小写字母组成。）

如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。

返回所有不常用单词的列表。

您可以按任何顺序返回列表。

**示例 1：**

> 输入：A = "this apple is sweet", B = "this apple is sour"
> 输出：["sweet","sour"]

**示例 2：**

> 输入：A = "apple apple", B = "banana"
> 输出：["banana"]
 
**提示：**

1. 0 <= A.length <= 200
2. 0 <= B.length <= 200
3. A 和 B 都只包含空格和小写字母。

**Answer**

*法一*

```js
var uncommonFromSentences = function(A, B) {
    let aArr = A.split(' ')
    let bArr = B.split(' ')
    let aMap = new Map()
    let bMap = new Map()
    let aOnce = []
    let bOnce = []
    for (let i = 0; i < aArr.length; i++) {
    	if (!aMap.has(aArr[i])) {
            aMap.set(aArr[i], 1)
    	} else {
    		aMap.set(aArr[i], aMap.get(aArr[i]) + 1)
    	}
    }
    for (let i = 0; i < bArr.length; i++) {
    	if (!bMap.has(bArr[i])) {
            bMap.set(bArr[i], 1)
    	} else {
    		bMap.set(bArr[i], bMap.get(bArr[i]) + 1)
    	}
    }
    for (let [key, val] of aMap) {
    	if (val === 1) {
    		aOnce.push(key)
    	}
    }
    for (let [key, val] of bMap) {
    	if (val === 1) {
    		bOnce.push(key)
    	}
    }
    let aa = aOnce.filter((item) => {
    	return  !bArr.includes(item)
    })
    let bb = bOnce.filter((item) => {
    	return  !aArr.includes(item)
    })
    return aa.concat(bb)
};
var A = "this apple is sweet";
var B = "this apple is sour";
console.log(uncommonFromSentences(A, B));
```

*法二*

```js
var uncommonFromSentences2 = function(A, B) {
    let arr = (A + ' ' + B).split(' '); 
    let map = new Map()
    let res = []
    for (let i = 0; i < arr.length; i++) {
    	if (!map.has(arr[i])) {
            map.set(arr[i], 1)
    	} else {
    		map.set(arr[i], map.get(arr[i]) + 1)
    	}
    }
    for (let [key, val] of map) {
    	if (val === 1) {
    		res.push(key)
    	}
    }
    return res
};

```

*法三*

```js
var uncommonFromSentences3 = function(A, B) {
    let arr = (A + ' ' + B).split(' ');   
    let res = arr.filter(i => arr.indexOf(i) == arr.lastIndexOf(i));
    return res;
};
```

# 888. 公平的糖果交换

爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 块糖的大小，B[j] 是鲍勃拥有的第 j 块糖的大小。

因为他们是朋友，所以他们想交换一个糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）

返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。

如果有多个答案，你可以返回其中任何一个。保证答案存在。

**示例 1：**

> 输入：A = [1,1], B = [2,2]
> 输出：[1,2]

**示例 2：**

> 输入：A = [1,2], B = [2,3]
> 输出：[1,2]

**示例 3：**

> 输入：A = [2], B = [1,3]
> 输出：[2,3]

**示例 4：**

> 输入：A = [1,2,5], B = [2,4]
> 输出：[5,4]
 
**提示：**

- 1 <= A.length <= 10000
- 1 <= B.length <= 10000
- 1 <= A[i] <= 100000
- 1 <= B[i] <= 100000
- 保证爱丽丝与鲍勃的糖果总量不同。
- 答案肯定存在。

**Answer**

```js
/**
 * @param {number[]} A
 * @param {number[]} B
 * @return {number[]}
 */
var fairCandySwap = function(A, B) {
	let sumA = 0;
	let sumB = 0;
    for (let item of A) {
        sumA += item
    }
    for (let item of B) {
        sumB += item
    }
    let diff = (sumA - sumB) / 2;
    for (let i = 0; i < A.length; i++) {
    	for (let j = 0; j < B.length; j++) {
    		if (A[i]-B[j] === diff) {
    			return [A[i], B[j]]
    		}
    	}
    }
};
var A = [1, 2];
var B = [2,3];
console.log(fairCandySwap(A, B));
```

# 892. 三维形体的表面积

在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。

每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。

请你返回最终形体的表面积。

**示例 1：**

> 输入：[[2]]
> 输出：10

**示例 2：**

> 输入：[[1,2],[3,4]]
> 输出：34

**示例 3：**

> 输入：[[1,0],[0,2]]
> 输出：16

**示例 4：**

> 输入：[[1,1,1],[1,0,1],[1,1,1]]
> 输出：32

**示例 5：**

> 输入：[[2,2,2],[2,1,2],[2,2,2]]
> 输出：46
 
**提示：**

- 1 <= N <= 50
- 0 <= grid[i][j] <= 50

**Answer**

```js
/**
 * @param {number[][]} grid
 * @return {number}
 */
var surfaceArea = function(grid) {
    let sum = 0;
    let N = grid.length;
    for (let i = 0; i < N; i++) {
        let item = grid[i];
        // 前后重叠
        let overlap = 0;
        // 左右重叠
        let overlap2 = 0;
        // 上下重叠
        let overlap3 = 0;
        for (let k = 0; k < N - 1; k++) {
            overlap += Math.min(item[k], item[k+1]) * 2
        }
        for (let k = 0; k < N - 1; k++) {
            overlap2 += Math.min(grid[k][i], grid[k+1][i]) * 2
        }
        for (let j = 0;j < N; j++) {
            sum += grid[i][j] * 6
            if (grid[i][j] > 1) {
                overlap3 += (grid[i][j] - 1 ) * 2
            }
        }
        sum = sum - overlap - overlap2 - overlap3
    }
    return sum
};
//var grid = [[2,2,2],[2,1,2],[2,2,2]];
//var grid = [[1,1,1],[1,0,1],[1,1,1]];
var grid = [[1,2],[3,4]];
console.log(surfaceArea(grid));
```

# 893. 特殊等价字符串组


你将得到一个字符串数组 A。

如果经过任意次数的移动，S == T，那么两个字符串 S 和 T 是特殊等价的。

一次移动包括选择两个索引 i 和 j，且 i ％ 2 == j ％ 2，交换 S[j] 和 S [i]。

现在规定，A 中的特殊等价字符串组是 A 的非空子集 S，这样不在 S 中的任何字符串与 S 中的任何字符串都不是特殊等价的。

返回 A 中特殊等价字符串组的数量。

**示例 1：**

> 输入：["a","b","c","a","c","c"]
> 输出：3
解释：3 组 ["a","a"]，["b"]，["c","c","c"]

**示例 2：**

> 输入：["aa","bb","ab","ba"]
> 输出：4
解释：4 组 ["aa"]，["bb"]，["ab"]，["ba"]

**示例 3：**

> 输入：["abc","acb","bac","bca","cab","cba"]
> 输出：3
解释：3 组 ["abc","cba"]，["acb","bca"]，["bac","cab"]

**示例 4：**

> 输入：["abcd","cdab","adcb","cbad"]
> 输出：1
解释：1 组 ["abcd","cdab","adcb","cbad"]
 

**提示：**

- 1 <= A.length <= 1000
- 1 <= A[i].length <= 20
- 所有 A[i] 都具有相同的长度。
- 所有 A[i] 都只由小写字母组成。


**题意理解：**

题目的意思就是按照等价分组。比如相同的肯定是同一组的，然后举个例子，奇数位相同的且偶数位整体相同的也视为同一组。例如，abcd, 和adcb, cbad, cdab这四个视为同一组。因为奇数位都是a和c, 偶数位都是b和d.这题最难的还是看懂。

**Answer**

```js
var numSpecialEquivGroups = function(A) {
    let set = new Set()
    for (let i = 0; i < A.length; i++) {
        let item = A[i];
        let odd = []
        let even = []
        for (let k = 0; k < item.length; k++) {
            if (k % 2 == 0) {
                odd.push(item[k]) 
            } else {
                even.push(item[k])
            }
        }
        set.add(odd.sort().join('') + even.sort().join(''))
    }
    return set.size
};

var A = ["abc","acb","bac","bca","cab","cba"];
var A = ["a","b","c","a","c","c"];
var A = ["aa","bb","ab","ba"];
var A = ["abcd","cdab","adcb","cbad"];
console.log(numSpecialEquivGroups(A));
```

# 896. 单调数列

如果数组是单调递增或单调递减的，那么它是单调的。

如果对于所有 i <= j，A[i] <= A[j]，那么数组 A 是单调递增的。 如果对于所有 i <= j，A[i]> = A[j]，那么数组 A 是单调递减的。

当给定的数组 A 是单调数组时返回 true，否则返回 false。

**示例 1：**

> 输入：[1,2,2,3]
> 输出：true

**示例 2：**

> 输入：[6,5,4,4]
> 输出：true

**示例 3：**

> 输入：[1,3,2]
> 输出：false

**示例 4：**

> 输入：[1,2,4,5]
> 输出：true

**示例 5：**

> 输入：[1,1,1]
> 输出：true
 
**提示：**

1. 1 <= A.length <= 50000
2. -100000 <= A[i] <= 100000

**Answer**

```js
/**
 * @param {number[]} A
 * @return {boolean}
 */
var isMonotonic = function(A) {
    let isUp = false;
    let isDown = false;
    if (A.length >= 3) {
        for (let i = 0; i < A.length-1; i++) {
            if (A[i] < A[i+1]) {
                // 前面比后面小
                isUp = true
            } else if (A[i] > A[i+1]) {
                // 前面比后面大
                isDown = true
            }
        }
    }
    // 同时出现 isUp = true && isUp = true，说明有问题
    return !(isUp && isDown)
};

var A = [11,11,9,4,3,3,3,1,-1,-1,3,3,3,5,5,5];
console.log(isMonotonic(A));
```

# 905. 按奇偶排序数组

给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。

你可以返回满足此条件的任何数组作为答案。

**示例：**

> 输入：[3,1,2,4]
> 输出：[2,4,3,1]
输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。
 

**提示：**

1. 1 <= A.length <= 5000
2. 0 <= A[i] <= 5000

**Answer**

```js
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortArrayByParity = function(A) {
    let oddArr = []
    let evenArr = []
    for (let item of A) {
        if(item % 2 == 0) {
           evenArr.push(item) 
        } else {
            oddArr.push(item)
        }
    }
    return evenArr.concat(oddArr)
};

var A = [11,11,9,4,3,3,3,1,-1,-1,3,3,3,5,5,5];
console.log(sortArrayByParity(A));
```

# 917. 仅仅反转字母

给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。

**示例 1：**

> 输入："ab-cd"
> 输出："dc-ba"

**示例 2：**

> 输入："a-bC-dEf-ghIj"
> 输出："j-Ih-gfE-dCba"

**示例 3：**

> 输入："Test1ng-Leet=code-Q!"
> 输出："Qedo1ct-eeLg=ntse-T!"
 

**提示：**

1. S.length <= 100
2. 33 <= S[i].ASCIIcode <= 122 
3. S 中不包含 \ or "

**Answer**

```js
/**
 * @param {string} S
 * @return {string}
 */
var reverseOnlyLetters = function(S) {
    let pat = /[^a-zA-Z]/
    let pat2 = /[^a-zA-Z]/g
    // 符号位置
    let mark = new Map()
    for (let i = 0; i < S.length; i++) {
        if (pat.test(S[i])) {
            mark.set(i, S[i])
        }
    }
    let S2 = S.replace(pat2, '').split('').reverse();
    for (let [key, val] of mark) {
        S2.splice(key,0,val)
    }
    return S2.join('')
};
var S = "7_28]";
console.log(reverseOnlyLetters(S));
```

# 922. 按奇偶排序数组 II

给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。

对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。

你可以返回任何满足上述条件的数组作为答案。

**示例：**

> 输入：[4,2,5,7]
> 输出：[4,5,2,7]
解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。

**提示：**

1. 2 <= A.length <= 20000
2. A.length % 2 == 0
3. 0 <= A[i] <= 1000

**Answer**

```js
var sortArrayByParityII = function(A) {
    let arr1 = []
    let arr2 = []
    A.forEach((item,index) => {
        if(item % 2 === 0) {
            arr1.push(item);
        } else {
            arr2.push(item);
        }
    });
    A.forEach((item, index) => {
        if(index % 2 !== 0) {
            A[index] = arr2.pop();
        } else {
            A[index] = arr1.pop();
        }
    });
    return A;
};
var A = [4,2,5,7];
console.log(sortArrayByParityII(A));
```

```js
var sortArrayByParityII = function(A) {
    let j = 1;
    for(let i = 0; i < A.length - 1; i = i + 2) {
        if((A[i] & 1) !== 0) { // 偶数
            while((A[j] & 1) !== 0) {
                j += 2;
            }
            [A[i], A[j]] = [A[j], A[i]];
        }
    }
    return A;
};
```

```js
var sortArrayByParityII = function (A) {
  if (A.length < 2) return 0
  let res = []
  let odd = 1
  let even = 0  //odd奇数 even偶数
  A.forEach(item => {
    if (item % 2 === 0) {
      res[even] = item
      even += 2
    } else {
      res[odd] = item
      odd += 2
    }
  });
  return res
};
```

# 925. 长按键入

你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。

你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。

**示例 1：**

> 输入：name = "alex", typed = "aaleex"
> 输出：true
解释：'alex' 中的 'a' 和 'e' 被长按。

**示例 2：**

> 输入：name = "saeed", typed = "ssaaedd"
> 输出：false
解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。

**示例 3：**

> 输入：name = "leelee", typed = "lleeelee"
> 输出：true

**示例 4：**

> 输入：name = "laiden", typed = "laiden"
> 输出：true
解释：长按名字中的字符并不是必要的。
 
**提示：**

1. name.length <= 1000
2. typed.length <= 1000
3. name 和 typed 的字符都是小写字母。

**Answer**

*法一*

```js
/**
 * @param {string} name
 * @param {string} typed
 * @return {boolean}
 */
var isLongPressedName = function(name, typed) {
    for (let i = 0; i < typed.length; i++) {
        if (typed[i] !== name[i]) {
          typed = typed.substr(0,i) + typed.substr(i+1)
          i--
        }
    }
    return typed === name
};
var name = "alex";
var typed = "aaleex";
// console.log(isLongPressedName(name, typed));
```

*法二：双指针*

```js
var isLongPressedName2 = function(name, typed) {
    let i = 0
    let j = 0
    while(name[i] && typed[j]) {
      if (name[i] === typed[j]) {
        i++
        j++
      } else {
        j++
      }
    }
    return i === name.length
};
```

# 929. 独特的电子邮件地址

每封电子邮件都由一个本地名称和一个域名组成，以 @ 符号分隔。

例如，在 alice@leetcode.com中， alice 是本地名称，而 leetcode.com 是域名。

除了小写字母，这些电子邮件还可能包含 '.' 或 '+'。

如果在电子邮件地址的本地名称部分中的某些字符之间添加句点（'.'），则发往那里的邮件将会转发到本地名称中没有点的同一地址。例如，"alice.z@leetcode.com” 和 “alicez@leetcode.com” 会转发到同一电子邮件地址。 （请注意，此规则不适用于域名。）

如果在本地名称中添加加号（'+'），则会忽略第一个加号后面的所有内容。这允许过滤某些电子邮件，例如 m.y+name@email.com 将转发到 my@email.com。 （同样，此规则不适用于域名。）

可以同时使用这两个规则。

给定电子邮件列表 emails，我们会向列表中的每个地址发送一封电子邮件。实际收到邮件的不同地址有多少？

**示例：**

> 输入：["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"]
> 输出：2
解释：实际收到邮件的是 "testemail@leetcode.com" 和 "testemail@lee.tcode.com"。
 

**提示：**

- 1 <= emails[i].length <= 100
- 1 <= emails.length <= 100
- 每封 emails[i] 都包含有且仅有一个 '@' 字符。

**Answer**

*法一：正则*

```js
/**
 * @param {string[]} emails
 * @return {number}
 */
var numUniqueEmails = function(emails) {
    let res = []
    // 匹配+和+后面的
    let pat = /(?=\+).*/
    // 匹配@左边的部分
    let pat2 = /.*(?=@)/
    // 匹配@右边的部分
    let pat3 = /(?<=@).*/
    emails.forEach(item => {
        //let [left, right] = item.split('@');
        let left = item.match(pat2)[0]
        let right = item.match(pat3)[0]
        left = left.replace(pat, '').replace(/\./g, '')
        res.push(`${left}@${right}`)
    })
    return new Set(res).size
};
var emails = ["test.email+alex@leetcode.com","test.e.mail+bob.cathy@leetcode.com","testemail+david@lee.tcode.com"];
console.log(numUniqueEmails(emails));
```

[(?<=)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Assertions?from=singlemessage)

```js
var numUniqueEmails2 = function(emails) {
    let res = []
    // 匹配+和+后面的
    let pat = /(?=\+).*/
    for (let item of emails) {
        let [left, right] = item.split('@');
        left = left.replace(pat, '').replace(/\./g, '')
        res.push(`${left}@${right}`)
    }
    return new Set(res).size
};
```

## 937. 重新排列日志文件

你有一个日志数组 logs。每条日志都是以空格分隔的字串。

对于每条日志，其第一个字为字母数字标识符。然后，要么：

标识符后面的每个字将仅由小写字母组成，或；
标识符后面的每个字将仅由数字组成。
我们将这两种日志分别称为字母日志和数字日志。保证每个日志在其标识符后面至少有一个字。

将日志重新排序，使得所有字母日志都排在数字日志之前。字母日志按内容字母顺序排序，忽略标识符；在内容相同时，按标识符排序。数字日志应该按原来的顺序排列。

返回日志的最终顺序。

**示例 ：**

> 输入：["a1 9 2 3 1","g1 act car","zo4 4 7","ab1 off key dog","a8 act zoo"]
> 输出：["g1 act car","a8 act zoo","ab1 off key dog","a1 9 2 3 1","zo4 4 7"]

**提示：**

1. 0 <= logs.length <= 100
2. 3 <= logs[i].length <= 100
3. logs[i] 保证有一个标识符，并且标识符后面有一个字。

**Answer**

# 941. 有效的山脉数组

给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。

让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：

A.length >= 3
在 0 < i < A.length - 1 条件下，存在 i 使得：
A[0] < A[1] < ... A[i-1] < A[i]
A[i] > A[i+1] > ... > A[B.length - 1]
 

**示例 1：**

> 输入：[2,1]
> 输出：false

**示例 2：**

> 输入：[3,5,5]
> 输出：false

**示例 3：**

> 输入：[0,3,2,1]
> 输出：true
 

**提示：**

- 0 <= A.length <= 10000
- 0 <= A[i] <= 10000 

**Answer**

*法一：找到最大数的索引*

```js
/**
 * @param {number[]} A
 * @return {boolean}
 */
var validMountainArray = function(A) {
    let max = A[0];
    let maxIndex = 0;
    let ALen = A.length
    if (ALen < 3) {
        return false
    } else {
        A.forEach((item, index) => {
            if (item > max) {
                max = item;
                maxIndex = index
            }
        })
        if (maxIndex === 0 || maxIndex === ALen - 1) {
            return false
        } else {
            for (let i = 0; i < maxIndex; i++) {
                if (A[i] >= A[i+1]) {
                    return false
                }
            }
            for (let i = maxIndex; i < ALen; i++) {
                if (A[i] <= A[i+1]) {
                    return false
                }
            }
            return true
        }

    }
};
var A = [2,4,3,2,1];
console.log(validMountainArray(A));
```

*法二：双指针*

推荐

```js
var validMountainArray2 = function(A) {
    let ALen = A.length
    if (ALen < 3) {
        return false
    } else {
        let i = 0;
        let j = ALen - 1;
        while(i < ALen - 2 && A[i] < A[i+1]) {
            i++
        }
        while(j > 1 && A[j] < A[j-1]) {
            j--
        }
        return i === j
    }
};
```

# 942. 增减字符串匹配

给定只含 "I"（增大）或 "D"（减小）的字符串 S ，令 N = S.length。

返回 [0, 1, ..., N] 的任意排列 A 使得对于所有 i = 0, ..., N-1，都有：

如果 S[i] == "I"，那么 A[i] < A[i+1]
如果 S[i] == "D"，那么 A[i] > A[i+1]
 
**示例 1：**

> 输出："IDID"
> 输出：[0,4,1,3,2]

**示例 2：**

> 输出："III"
> 输出：[0,1,2,3]

**示例 3：**

> 输出："DDI"
> 输出：[3,2,0,1]

**提示：**

- 1 <= S.length <= 1000
- S 只包含字符 "I" 或 "D"。

**Answer**

```js
var diStringMatch = function(S) {
    let len = S.length;
    let res = [];
    let small = 0, big = len;
    for(let i = 0; i < len; i++) {
        if(S[i] === 'I') {
            res[i] = small++;
        } else {
            res[i] = big--;
        }
    }
    res[len] = big;
    return res;
};
var S = "DDI";
console.log(diStringMatch(S));
```

# 949. 给定数字能组成的最大时间

给定一个由 4 位数字组成的数组，返回可以设置的符合 24 小时制的最大时间。

最小的 24 小时制时间是 00:00，而最大的是 23:59。从 00:00 （午夜）开始算起，过得越久，时间越大。

以长度为 5 的字符串返回答案。如果不能确定有效时间，则返回空字符串。

**示例 1：**

输入：[1,2,3,4]
输出："23:41"

**示例 2：**

输入：[5,5,5,5]
输出："" 

**提示：**

1. A.length == 4
2. 0 <= A[i] <= 9

**Answer**

暴力全排列

**思路：**

遍历所有可能的时间，找到最大的那个。

**算法：**

用 (i, j, k, l) 表示数组索引 (0, 1, 2, 3)，之后做全排列，对于每个排列，会有 A[i]A[j] : A[k]A[l]。

检查每个排列对应的时间是否合法，例如检查 10\*A[i] + A[j] 是不是小于 24 ；10\*A[k] + A[l] 是不是小于 60。

最后把最大的有效时间输出就可以了。

```js
/**
 * @param {number[]} A
 * @return {string}
 */
var largestTimeFromDigits = function(A) {
    let max = -1;
    for(let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
            if (j != i) {
                for (k = 0; k < 4; k++) {
                    if ( k!= j && k != i) {
                        // 三个数位置确定了，最后一个数一定是6-i-j-k
                        let l = 6 - i - j - k;
                        let hours = 10 * A[i] + A[j]
                        let mins = 10 * A[k] + A[l]
                        if (hours < 24 && mins < 60) {
                            max = Math.max(max, hours * 60 + mins)
                        }
                    }
                }
            }
        }
    }
    return max >= 0 ? `${parseInt(max/60)}:${max%60}`: ''
};
var A = [1,2,3,4];
console.log(largestTimeFromDigits(A));
```

# 953. 验证外星语词典

某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。

给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。

**示例 1：**

> 输入：words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"
> 输出：true
解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。

**示例 2：**

> 输入：words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"
> 输出：false
解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。

**示例 3：**

> 输入：words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"
> 输出：false
解释：当前三个字符 "app" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 "apple" > "app"，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。
 

**提示：**

1. 1 <= words.length <= 100
2. 1 <= words[i].length <= 20
3. order.length == 26
4. 在 words[i] 和 order 中的所有字符都是英文小写字母。

**Answer**

```js
/**
 * @param {string[]} words
 * @param {string} order
 * @return {boolean}
 */
var isAlienSorted = function(words, order) {
    let map = new Array(26);
    for(let i = 0; i < order.length; i++){
        map[order[i].charCodeAt()-97] = i;
    }
    for(let i = 1; i < words.length; i++){
        if(map[words[i][0].charCodeAt()-97] <= map[words[i-1][0].charCodeAt()-97]) return false;
    }
    return true;
};
var words = ["hello","leetcode"];
var order = "hlabcdefgijkmnopqrstuvwxyz";
console.log(isAlienSorted(words, order));
```

# 961. 重复 N 次的元素

在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。

返回重复了 N 次的那个元素。

**示例 1：**

> 输入：[1,2,3,3]
> 输出：3

**示例 2：**

> 输入：[2,1,2,5,3,2]
> 输出：2

**示例 3：**

> 输入：[5,1,5,2,5,3,5,4]
> 输出：5

**提示：**

1. 4 <= A.length <= 10000
2. 0 <= A[i] < 10000
3. A.length 为偶数

**Answer**

```js
/**
 * @param {number[]} A
 * @return {number}
 */
var repeatedNTimes = function(A) {
    let set = new Set();
    for (let item of A) {
        if(!set.has(item)) {
            set.add(item)
        } else {
            return item
        }
    }
};
var A = [5,1,5,2,5,3,5,4];
console.log(repeatedNTimes(A));
```

# 970. 强整数

给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i >= 0 且 j >= 0，那么我们认为该整数是一个强整数。

返回值小于或等于 bound 的所有强整数组成的列表。

你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。

**示例 1：**

> 输入：x = 2, y = 3, bound = 10
> 输出：[2,3,4,5,7,9,10]
解释： 
2 = 2^0 + 3^0
3 = 2^1 + 3^0
4 = 2^0 + 3^1
5 = 2^1 + 3^1
7 = 2^2 + 3^1
9 = 2^3 + 3^0
10 = 2^0 + 3^2

**示例 2：**

> 输入：x = 3, y = 5, bound = 15
> 输出：[2,4,6,8,10,14]

**提示：**

- 1 <= x <= 100
- 1 <= y <= 100
- 0 <= bound <= 10^6

**Answer**

```js
/**
 * @param {number} x
 * @param {number} y
 * @param {number} bound
 * @return {number[]}
 */
var powerfulIntegers = function(x, y, bound) {
    let set = new Set()
    for (let i = 0; Math.pow(x,i) <= bound && i < 20; i++) {
        for (let j = 0; Math.pow(y,j) <= bound && j < 20; j++) {
            let item = Math.pow(x,i) + Math.pow(y,j)
            if (item <= bound) {
                set.add(item)
            }
        }
    }
    return [...set]
};
var x = 2, y = 1, bound = 10;
console.log(powerfulIntegers(x, y, bound));
```

# 976. 三角形的最大周长

给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。

如果不能形成任何面积不为零的三角形，返回 0。

**示例 1：**

> 输入：[2,1,2]
> 输出：5

**示例 2：**

> 输入：[1,2,1]
> 输出：0

**示例 3：**

> 输入：[3,2,3,4]
> 输出：10

**示例 4：**

> 输入：[3,6,2,3]
> 输出：8

**提示：**

1. 3 <= A.length <= 10000
2. 1 <= A[i] <= 10^6

**Answer**

*法一：超出时间*

故舍去，不可取

```js
/**
 * @param {number[]} A
 * @return {number}
 */
var largestPerimeter = function(A) {
    let n = A.length;
    let max = 0;
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            if (j != i) {
                for (let k = 0; k < n; k++) {
                    if (k != i && k != j) {
                        if (A[i] + A[j] > A[k] && A[i] + A[k] > A[j] && A[j] + A[k] > A[i]) {
                            max = Math.max(max, A[i] + A[j] + A[k])
                        }
                    }
                }
            }
        }
    }
    return max
};
var A = [3,2,3,4];
console.log(largestPerimeter(A));
```

*法二：先排序*

```js
var largestPerimeter2 = function(A) {
    A.sort((a, b) => a - b)
    let n = A.length;
    for (let i = n-3; i >= 0; i--) {
        if (A[i] + A[i+1] > A[i+2]) {
            return A[i] + A[i+1] + A[i+2]
        }
    }
    return 0
};
```

# 977. 有序数组的平方

给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。 

**示例 1：**

> 输入：[-4,-1,0,3,10]
> 输出：[0,1,9,16,100]

**示例 2：**

> 输入：[-7,-3,2,3,11]
> 输出：[4,9,9,49,121]

**提示：**

1. 1 <= A.length <= 10000
2. -10000 <= A[i] <= 10000
3. A 已按非递减顺序排序。

**Answer**

```js
/**
 * @param {number[]} A
 * @return {number[]}
 */
var sortedSquares = function(A) {
    let res = []
    A.forEach((item) => {
        res.push(item * item)
    })
    return res.sort((a, b) => a - b)
};
var A = [-4,-1,0,3,10];
console.log(sortedSquares(A));
```

# 985. 查询后的偶数和

给出一个整数数组 A 和一个查询数组 queries。

对于第 i 次查询，有 val = queries[i][0], index = queries[i][1]，我们会把 val 加到 A[index] 上。然后，第 i 次查询的答案是 A 中偶数值的和。

（此处给定的 index = queries[i][1] 是从 0 开始的索引，每次查询都会永久修改数组 A。）

返回所有查询的答案。你的答案应当以数组 answer 给出，answer[i] 为第 i 次查询的答案。 

**示例：**

> 输入：A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]
> 输出：[8,6,2,4]
解释：
开始时，数组为 [1,2,3,4]。
将 1 加到 A[0] 上之后，数组为 [2,2,3,4]，偶数值之和为 2 + 2 + 4 = 8。
将 -3 加到 A[1] 上之后，数组为 [2,-1,3,4]，偶数值之和为 2 + 4 = 6。
将 -4 加到 A[0] 上之后，数组为 [-2,-1,3,4]，偶数值之和为 -2 + 4 = 2。
将 2 加到 A[3] 上之后，数组为 [-2,-1,3,6]，偶数值之和为 -2 + 6 = 4。
 

**提示：**

1. 1 <= A.length <= 10000
2. -10000 <= A[i] <= 10000
3. 1 <= queries.length <= 10000
4. -10000 <= queries[i][0] <= 10000
5. 0 <= queries[i][1] < A.length

**Answer**

*法一：双循环*

缺点：当queries.length 较大时，超出时间限制

```js
/**
 * @param {number[]} A
 * @param {number[][]} queries
 * @return {number[]}
 */
var sumEvenAfterQueries = function(A, queries) {
    let qLen = queries.length;
    let ALen = A.length;
    let res = []
    for (let i = 0; i < qLen; i++) {
    	A[queries[i][1]] = A[queries[i][1]] + queries[i][0]
    	let sum = 0;
    	for (let j = 0; j < ALen; j++) {
    		// 偶数
    		if (A[j] % 2 == 0) {
    			sum += A[j]
    		}
    	}
    	res.push(sum)
    }
    return res
};
var A = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]];
console.log(sumEvenAfterQueries(A, queries));
```

*法二*

先记录查询前原数组偶数和S,
对于每次查询 如果A[index] 是偶数，S -= A[index],
如果A[index] + VAL 是偶数， S += A[index] + VAL。


```js
var sumEvenAfterQueries2 = function(A, queries) {
    let qLen = queries.length;
    let ALen = A.length;
    let res = [];
    let evenSum = 0;
    A.forEach((item) => {
        if (item % 2 == 0) {
        	evenSum += item
        }
    })
    for (let i = 0; i < qLen; i++) {
    	let index = queries[i][1]
    	let val = queries[i][0]
        if (A[index] % 2 == 0) {
        	evenSum -= A[index]
        } 
        A[index] += val
        if (A[index] % 2 == 0) {
        	evenSum += A[index]
        }
    	res.push(evenSum)
    }
    return res
};
```

# 989. 数组形式的整数加法

对于非负整数 X 而言，X 的数组形式是每位数字按从左到右的顺序形成的数组。例如，如果 X = 1231，那么其数组形式为 [1,2,3,1]。

给定非负整数 X 的数组形式 A，返回整数 X+K 的数组形式。

**示例 1：**

> 输入：A = [1,2,0,0], K = 34
> 输出：[1,2,3,4]
解释：1200 + 34 = 1234

**示例 2：**

> 输入：A = [2,7,4], K = 181
> 输出：[4,5,5]
解释：274 + 181 = 455

**示例 3：**

> 输入：A = [2,1,5], K = 806
> 输出：[1,0,2,1]
解释：215 + 806 = 1021

**示例 4：**

> 输入：A = [9,9,9,9,9,9,9,9,9,9], K = 1
> 输出：[1,0,0,0,0,0,0,0,0,0,0]
解释：9999999999 + 1 = 10000000000

**提示：**

1 <= A.length <= 10000
0 <= A[i] <= 9
0 <= K <= 10000
如果 A.length > 1，那么 A[0] != 0

**Answer**

```js
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number[]}
 */
var addToArrayForm = function(A, K) {
    const Aarr = A.reverse();
    const Karr = K.split('').reverse().map((x) => +x)
    const maxLen = Math.max(Aarr.length, Karr.length)
    let res = []
    let flag = false
    for (let i = 0; i < maxLen; i++) {
        sum = (Aarr[i] ? Aarr[i] : 0) + (Karr[i] ? Karr[i] : 0) + (flag ? 1 : 0)
        flag = sum >= 10
        res.push(sum % 10)
    }
    if (flag) {
        res.push(1)
    }
    return res.reverse()
};
var A = [2,7,4], K = 181
console.log(addToArrayForm(A, K));
```

## 994. 腐烂的橘子

在给定的网格中，每个单元格可以有以下三个值之一：

值 0 代表空单元格；
值 1 代表新鲜橘子；
值 2 代表腐烂的橘子。
每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。

返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png)

> 输入：[[2,1,1],[1,1,0],[0,1,1]]
> 输出：4

**示例 2：**

> 输入：[[2,1,1],[0,1,1],[1,0,1]]
> 输出：-1
解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。

**示例 3：**

> 输入：[[0,2]]
> 输出：0
解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。
 
**提示：**

1. 1 <= grid.length <= 10
2. 1 <= grid[0].length <= 10
3. grid[i][j] 仅为 0、1 或 2

**Answer**

# 997. 找到小镇的法官

在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。

如果小镇的法官真的存在，那么：

小镇的法官不相信任何人。
每个人（除了小镇法官外）都信任小镇的法官。
只有一个人同时满足属性 1 和属性 2 。
给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。

如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。

**示例 1：**

> 输入：N = 2, trust = [[1,2]]
> 输出：2

**示例 2：**

> 输入：N = 3, trust = [[1,3],[2,3]]
> 输出：3

**示例 3：**

> 输入：N = 3, trust = [[1,3],[2,3],[3,1]]
> 输出：-1

**示例 4：**

> 输入：N = 3, trust = [[1,2],[2,3]]
> 输出：-1

**示例 5：**

> 输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
> 输出：3
 
**提示：**

1. 1 <= N <= 1000
2. trust.length <= 10000
3. trust[i] 是完全不同的
4. trust[i][0] != trust[i][1]
5. 1 <= trust[i][0], trust[i][1] <= N

**Answer**

```js
var findJudge = function(N, trust) {
	if (N == 1 && trust.length == 0) {
        return 1
    }
    // 相信法官的人
    let peoples = new Set();
    // 可能为法官的人
    let judges = new Set();
    trust.forEach((item) => {
    	judges.add(item[1])
    })
    trust.forEach((item) => {
    	if (judges.has(item[0])) {
    		judges.delete(item[0])
    	}
    })
    let judge = [...judges][0]
    if (judges.size == 1) {
        trust.forEach((item) => {
            if (item[1] === judge) {
                peoples.add(item[0])
            }
        })
    }
    if (peoples.size == N - 1 && !peoples.has(judge)) {
    	return judge
    }
    return -1
};
var N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]
//var N = 3, trust = [[1,2],[2,3]]
console.log(findJudge(N, trust));
```

# 1002. 查找常用字符

给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。

你可以按任意顺序返回答案。

**示例 1：**

> 输入：["bella","label","roller"]
> 输出：["e","l","l"]

**示例 2：**

> 输入：["cool","lock","cook"]
> 输出：["c","o"]
 
**提示：**

1. 1 <= A.length <= 100
2. 1 <= A[i].length <= 100
3. A[i][j] 是小写字母

**Answer**

```js
var commonChars = function(A) {
    let res = []
    for (let i = 0; i < A[0].length; i++) {
        let flag = true
        for (let j = 1; j < A.length; j++) {
            let index = A[j].indexOf(A[0][i])
            if (index !== -1) {
                A[j] = A[j].substr(0, index) + A[j].substr(index + 1)
            } else {
                flag = false
                break
            }
        }
        if (flag) {
            res.push(A[0][i])
        }
    }
    return res
};
var A = ["bella","label","roller"]
console.log(commonChars(A));
```

# 1005. K 次取反后最大化的数组和

给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）

以这种方式修改数组后，返回数组可能的最大和。 

**示例 1：**

> 输入：A = [4,2,3], K = 1
> 输出：5
解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。

**示例 2：**

> 输入：A = [3,-1,0,2], K = 3
> 输出：6
解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。

**示例 3：**

> 输入：A = [2,-3,-1,5,-4], K = 2
> 输出：13
解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。
 
**提示：**

1. 1 <= A.length <= 10000
2. 1 <= K <= 10000
3. -100 <= A[i] <= 100

**Answer**

```js
/**
 * @param {number[]} A
 * @param {number} K
 * @return {number}
 */
var largestSumAfterKNegations = function(A, K) {
    // 从小到大排序
    A.sort((a, b) => a - b)
    // 将数组中的负数尽可能的变成正数
    for (let i = 0; i < A.length; i++) {
        if (A[i] < 0 && K > 0) {
            A[i] = -A[i];
            K--
        }
    }
    // 再次从小到大排序
    A.sort((a, b) => a - b)
    // 当数组没有0时，K 为奇数，我们不得不把最小的一个的正数变成负数
    if (K % 2 !== 0 && A.indexOf(0) == -1) {
        A[0] = -A[0]
    }
    // 数组求和
    let sum = 0;
    A.forEach((item) => {
        sum += item
    })
    return sum
};
var A = [2,-3,-1,5,-4], K = 2
console.log(largestSumAfterKNegations(A, K));
```

# 1009. 十进制整数的反码

每个非负整数 N 都有其二进制表示。例如， 5 可以被表示为二进制 "101"，11 可以用二进制 "1011" 表示，依此类推。注意，除 N = 0 外，任何二进制表示中都不含前导零。

二进制的反码表示是将每个 1 改为 0 且每个 0 变为 1。例如，二进制数 "101" 的二进制反码为 "010"。

给定十进制数 N，返回其二进制表示的反码所对应的十进制整数。

**示例 1：**

> 输入：5
> 输出：2
解释：5 的二进制表示为 "101"，其二进制反码为 "010"，也就是十进制中的 2 。

**示例 2：**

> 输入：7
> 输出：0
解释：7 的二进制表示为 "111"，其二进制反码为 "000"，也就是十进制中的 0 。

**示例 3：**

> 输入：10
> 输出：5
解释：10 的二进制表示为 "1010"，其二进制反码为 "0101"，也就是十进制中的 5 。
 
**提示：**

- 0 <= N < 10^9

**Answer**

```js
/**
 * @param {number} N
 * @return {number}
 */
var bitwiseComplement = function(N) {
    let NTo2 = N.toString(2)
    let len = NTo2.length;
    let res2 = ''
    for (let i = 0; i < len; i++) {
        if (NTo2[i] == 1) {
            res2 += 0
        } else {
            res2 += 1
        }
    }
    return parseInt(res2,2)
};
var N = 7
console.log(bitwiseComplement(N));
```

# 1013. 将数组分成和相等的三个部分

给定一个整数数组 A，只有我们可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。

形式上，如果我们可以找出索引 i+1 < j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。

**示例 1：**

> 输出：[0,2,1,-6,6,-7,9,1,2,0,1]
> 输出：true
解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1

**示例 2：**

> 输入：[0,2,1,-6,6,7,9,-1,2,0,1]
> 输出：false

**示例 3：**

> 输入：[3,3,6,5,-2,2,5,1,-9,4]
> 输出：true
解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4
 
**提示：**

1. 3 <= A.length <= 50000
2. -10000 <= A[i] <= 10000

**Answer**

```js
var canThreePartsEqualSum = function(A) {
    let sum = 0
    for (let val of A) {
        sum += val
    }
    if (sum % 3 !== 0) {
        return false
    }
    let one_third = sum / 3;
    let sum1 = 0
    let sum3 = 0
    for (i = 0; i < A.length; i++) {
        if (sum1 !== one_third) {
            sum1 += A[i]
        } else {
            break
        }
    }
    for (j = A.length - 1; j >= 0; j--) {
        if (sum3 !== one_third) {
            sum3 += A[j]
        } else {
            break
        }
    }
    return i <= j
};
var A = [3,3,6,5,-2,2,5,1,-9,4]
var A = [0,2,1,-6,6,-7,9,1,2,0,1]
var A = [0,2,1,-6,6,7,9,-1,2,0,1]
console.log(canThreePartsEqualSum(A));
```

# 1018. 可被 5 整除的二进制前缀

给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。

返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。

**示例 1：**

> 输入：[0,1,1]
> 输出：[true,false,false]
解释：
输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。

**示例 2：**

输入：[1,1,1]
输出：[false,false,false]

**示例 3：**

输入：[0,1,1,1,1,1]
输出：[true,false,false,false,true,false]

**示例 4：

输入：[1,1,1,0,1]
输出：[false,false,false,false,false]
 
**提示：**

1. 1 <= A.length <= 30000
2. A[i] 为 0 或 1

**Answer**

将一个二进制数组转成十进制的算法

```js
i = 0, decimal = decimal * 2 + A[0] = A[0]

i = 1, decimal = decimal * 2 + A[1] 
               = A[0] * 2 + A[1]

i = 2, decimal = decimal * 2 + A[2] 
               = (A[0] * 2 + A[1]) * 2 + A[2] 
               = A[0] * 2 * 2 + A[1] * 2 + A[2]

i = 3, decimal = decimal * 2 + A[3]
               = (A[0] * 2 * 2 + A[1] * 2 + A[2]) * 2 + A[3]
               = A[0] * 2 * 2 * 2 + A[1] * 2 * 2 + A[2] * 2 + A[3]
...
```

```js
var prefixesDivBy5 = function(A) {
    let res = []
    // 十进制
    let decimal = 0;
    for (let i = 0; i < A.length; i++) {
        // 将二进制都转换成十进制数
        decimal = decimal * 2 + A[i];
        res.push(decimal)
    }
    return res
};
```

var A = [1,1,1,0,1]
AToDecimal = [1, 3, 7, 14, 29]


**思路:**

[1,1,1,0,1]

```shell
第一步：[1] = 0*2+1 = 1;                //被5取模=1
第二步：[1,1] = 1*2+1 = 3;              //被5取模=3
第三步：[1,1,1] = 3*2+1 = 7;            //被5取模=2
第四步：[1,1,1,0] = 7*2+0 = 14;         //被5取模=4
第五步：[1,1,1,0,1] = 14*2+1 = 29;      //被5取模=4
```
如果每步计算 2 的幂，结果会越来越大，考虑采用每次结果的模进行计算

```shell
第一步：[1] = (0*2+1)%5 = 1;            //被5取模=1
第二步：[1,1] = (1*2+1)%5 = 3;          //被5取模=3
第三步：[1,1,1] = (3*2+1)%5 = 2;        //被5取模=2
第四步：[1,1,1,0] = (2*2+0)%5 = 4;      //被5取模=4
第五步：[1,1,1,0,1] = (4*2+1)%5 = 4;    //被5取模=4
```

```js
var prefixesDivBy5 = function(A) {
    let res = []
    // 十进制
    let decimal = 0;
    for (let i = 0; i < A.length; i++) {
        // 将二进制都转换成十进制数
        decimal = decimal * 2 + A[i];
        // 取模
        decimal = decimal % 5;
        if (decimal == 0) {
            res.push(true)
        } else {
            res.push(false)
        }
    }
    return res
};
```

# 1021. 删除最外层的括号

有效括号字符串为空 ("")、"(" + A + ")" 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。

如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。

给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。

对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。

**示例 1：**

> 输入："(()())(())"
> 输出："()()()"
解释：
输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，
删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。

**示例 2：**

> 输入："(()())(())(()(()))"
> 输出："()()()()(())"
解释：
输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，
删除每隔部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。

**示例 3：**

> 输入："()()"
> 输出：""
解释：
输入字符串为 "()()"，原语化分解得到 "()" + "()"，
删除每个部分中的最外层括号后得到 "" + "" = ""。

**提示：**

1. S.length <= 10000
2. S[i] 为 "(" 或 ")"
3. S 是一个有效括号字符串

**Answer**

```js
/**
 * @param {string} S
 * @return {string}
 */
var removeOuterParentheses = function(S) {
    let arr = [];
    let k = 0;
    let primitives = []
    for (let i = 0; i < S.length; i++) {
        if (S[i] == '(') {
            arr.push('(')
        } else {
            arr.pop()
        }
        if (arr.length == 0) {
            primitives.push(S.substring(k,i + 1))
            k = i + 1
        }
    }
    return primitives.map((item) => item.slice(1,item.length - 1)).join('')
};
var S = "(()())(())(()(()))"
console.log(removeOuterParentheses(S));
```

# 1025. 除数博弈

爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。

最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：

选出任一 x，满足 0 < x < N 且 N % x == 0 。
用 N - x 替换黑板上的数字 N 。
如果玩家无法执行这些操作，就会输掉游戏。

只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。

**示例 1：**

> 输入：2
> 输出：true
解释：爱丽丝选择 1，鲍勃无法进行操作。

**示例 2：**

> 输入：3
> 输出：false
解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。
 

**提示：**

- 1 <= N <= 1000

**Answer**

•	如果N是奇数，因为奇数的所有因数都是奇数，因此 N 进行一次 N-x 的操作结果一定是偶数，所以如果 a 拿到了一个奇数，那么轮到 b 的时候，b拿到的肯定是偶数，这个时候 b 只要进行 -1， 还给 a 一个奇数，那么这样子b就会一直拿到偶数，到最后b一定会拿到最小偶数2，a就输了。 
•	所以如果游戏开始时Alice拿到N为奇数，那么她必输，也就是false。如果拿到N为偶数，她只用 -1，让bob 拿到奇数，最后bob必输，结果就是true。 
```js
var divisorGame = function(N) {
    return N % 2 == 0
};
var N = 6
console.log(divisorGame(N));
```

# 1029. 两地调度

公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。

返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。

**示例：**

> 输入：[[10,20],[30,200],[400,50],[30,20]]
> 输出：110
解释：
第一个人去 A 市，费用为 10。
第二个人去 A 市，费用为 30。
第三个人去 B 市，费用为 50。
第四个人去 B 市，费用为 20。

最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。

**提示：**

1. 1 <= costs.length <= 100
2. costs.length 为偶数
3. 1 <= costs[i][0], costs[i][1] <= 1000

**Answer**

```js
/**
 * @param {number[][]} costs
 * @return {number}
 */
var twoCitySchedCost = function(costs) {
	// 让其以costs[0]-costs[1]的差值从小到大排序。
    costs.sort((a, b) => a[0] - a[1] - (b[0] - b[1]))
    let sum = 0;
    // 前一半取去A市，后一半取去B市，
    // 前一半是去A市最合适，后一半市去B市最合适。
    for (let i = 0; i < costs.length; i++) {
    	if (i < costs.length / 2) {
    		sum += costs[i][0]
    	} else {
    		sum += costs[i][1]
    	}
    }
    return sum
};
var costs = [[10,20],[30,200],[400,50],[30,20]]
console.log(twoCitySchedCost(costs));
```

# 1033. 移动石子直到连续

三枚石子放置在数轴上，位置分别为 a，b，c。

每一回合，我们假设这三枚石子当前分别位于位置 x, y, z 且 x < y < z。从位置 x 或者是位置 z 拿起一枚石子，并将该石子移动到某一整数位置 k 处，其中 x < k < z 且 k != y。

当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。

要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves]

**示例 1：**

> 输入：a = 1, b = 2, c = 5
> 输出：[1, 2]
解释：将石子从 5 移动到 4 再移动到 3，或者我们可以直接将石子移动到 3。

**示例 2：**

> 输入：a = 4, b = 3, c = 2
> 输出：[0, 0]
解释：我们无法进行任何移动。

**提示：**

1. 1 <= a <= 100
2. 1 <= b <= 100
3. 1 <= c <= 100
4. a != b, b != c, c != a

**Answer**

- 最小步数
最大次数就是一步一步往中间挪，所需的步数是z-x-2。因为z和x之间能移动的空间是z-x-1，还要去掉一个y占的位置，所以最终移动的最多步数是z-x-2。

- 最小步数呢
最小值为0：如果x,y,z三个值本身就挨着，那么不用移动就游戏结束了。
最小值为1：如果x和y之间只有一个位置，那么z移动到这个空位，只移动1次也就结束了。
最小值为2：除了上面两种情况，每次都把x移动到y-1或把z移动到y+1，那么只要两步就结束了。

```js
var numMovesStones = function(a, b, c) {
    let arr = [a, b, c]
    arr.sort((a, b) => a - b)
    a = arr[0]
    b = arr[1]
    c = arr[2]
    let maxMoves;
    let minMoves;
    if (b-a == 1 && c-b == 1) {
        maxMoves = 0
    } else if (b-a == 1 && c-b != 1) {
        maxMoves = c-b-1
    } else if (b-a != 1 && c-b == 1){
        maxMoves = b-a-1
    } else {
        maxMoves = c-a-2
    }

    if (b-a == 1 && c-b == 1) {
        minMoves = 0
    } else if (b-a == 1 || c-b == 1 || b-a == 2 || c-b == 2) {
        minMoves = 1
    } else {
        minMoves = 2
    }
    return [minMoves, maxMoves]
}
var a = 1, b = 2, c = 5
console.log(numMovesStones(a, b, c));
```

# 1037. 有效的回旋镖

回旋镖定义为一组三个点，这些点各不相同且不在一条直线上。

给出平面上三个点组成的列表，判断这些点是否可以构成回旋镖。

**示例 1：**

> 输入：[[1,1],[2,3],[3,2]]
> 输出：true

**示例 2：**

> 输入：[[1,1],[2,2],[3,3]]
> 输出：false 

**提示：**

1. points.length == 3
2. points[i].length == 2
3. 0 <= points[i][j] <= 100

**Answer**

判断斜率是否相等

```js
var isBoomerang = function(points) {
    const dx = points[1][0] - points[0][0];
    const dy = points[1][1] - points[0][1];
    const ex = points[2][0] - points[0][0];
    const ey = points[2][1] - points[0][1];
    return dx * ey != dy * ex;
};
var points = [[1,1],[2,2],[3,3]]
console.log(isBoomerang(points));
```

# 1046. 最后一块石头的重量

有一堆石头，每块石头的重量都是正整数。

每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：

- 如果 x == y，那么两块石头都会被完全粉碎；
- 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。

最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。

**提示：**

1. 1 <= stones.length <= 30
2. 1 <= stones[i] <= 1000

**Answer**

```js
var lastStoneWeight = function(stones) {
    while(stones.length > 1) {
    	stones.sort((a, b) => b - a)
    	stone1 = stones.shift()
    	stone2 = stones.shift()
    	if (stone1 !== stone2) {
    		stones.push(stone2-stone1)
    	}
    }
    return stones[0] ? stones[0] : 0
};
var points = [4,3,2,1]
console.log(lastStoneWeight(points));
```

# 1047. 删除字符串中的所有相邻重复项

给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。

在 S 上反复执行重复项删除操作，直到无法继续删除。

在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。

**示例：**

> 输入："abbaca"
> 输出："ca"
解释：
例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。

**提示：**

1. 1 <= S.length <= 20000
2. S 仅由小写英文字母组成。

**Answer**

*法一：正则匹配*

```js
var removeDuplicates = function(S) {
    let pat = /([a-z])\1/
    while(pat.test(S)) {
        S = S.replace(pat.exec(S)[0], '')
    }
    return S
};
var S = "abbaca"
console.log(removeDuplicates(S));
```

*法二：借用顺序栈*

```js
var removeDuplicates = function(S) {
    let arr = []
    for (let i = 0; i < S.length; i++) {
        let index = arr.length > 0 ? arr.length - 1 : 0;
        if (S[i] == arr[index]) {
            arr.pop()
        } else {
            arr.push(S[i])
        }
    }
    return arr.join('')
};
```

# 1051. 高度检查器

学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。

请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。 

**示例：**

> 输入：[1,1,4,2,1,3]
> 输出：3
解释：
高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。
 

**提示：**

- 1 <= heights.length <= 100
- 1 <= heights[i] <= 100

**Answer**

```js
var heightChecker = function(heights) {
    let count = 0
    let heights2 = [...heights]
    heights.sort((a, b) => a - b)
    for(let i = 0; i < heights.length; i++) {
        if (heights[i] !== heights2[i]) {
            count++
        }
    }
    return count
};
var heights = [1,1,4,2,1,3]
console.log(heightChecker(heights));
```

# 1071. 字符串的最大公因子

对于字符串 S 和 T，只有在 S = T + ... + T（T 与自身连接 1 次或多次）时，我们才认定 “T 能除尽 S”。

返回字符串 X，要求满足 X 能除尽 str1 且 X 能除尽 str2。

**示例 1：**

> 输入：str1 = "ABCABC", str2 = "ABC"
> 输出："ABC"

**示例 2：**

> 输入：str1 = "ABABAB", str2 = "ABAB"
> 输出："AB"

**示例 3：**

> 输入：str1 = "LEET", str2 = "CODE"
> 输出：""

**提示：**

1. 1 <= str1.length <= 1000
2. 1 <= str2.length <= 1000
3. str1[i] 和 str2[i] 为大写英文字母

**Answer**

```js
/**
 * @param {string} str1
 * @param {string} str2
 * @return {string}
 */
function getLongShort(a, b) { 
    // 字符串排序函数，返回的数组中，长的在前，短的在后
    return [a, b].sort((a, b) => b.length - a.length);
}

var gcdOfStrings = function (str1, str2) {
    let [long, short] = getLongShort(str1, str2);
    while (short !== long) {
        if (!long.includes(short)) {
            return '';
        }
        let temp = long.replace(short, '');
        [long, short] = getLongShort(short, temp);
    }
    return short;
};
var str1 = "ABABAB", str2 = "ABAB"
console.log(gcdOfStrings(str1, str2));
```

```js
var gcdOfStrings = function (str1, str2) {
    let len1 = str1.length;
    let len2 = str2.length;
    if (len1 == len2) {
        if (str1 == str2) {
            return str1
        } else {
            return ''
        }
    } else if (len1 > len2) {
        let temp = str1.replace(str2, '');
        return gcdOfStrings(temp, str2)
    } else {
        let temp = str2.replace(str1, '');
        return gcdOfStrings(temp, str1)
    }
};
```


# 1078. Bigram 分词

给出第一个词 first 和第二个词 second，考虑在某些文本 text 中可能以 "first second third" 形式出现的情况，其中 second 紧随 first 出现，third 紧随 second 出现。

对于每种这样的情况，将第三个词 "third" 添加到答案中，并返回答案。

**示例 1：**

> 输入：text = "alice is a good girl she is a good student", first = "a", second = "good"
> 输出：["girl","student"]

**示例 2：**

> 输入：text = "we will we will rock you", first = "we", second = "will"
> 输出：["we","rock"]
 
**提示：**

1. 1 <= text.length <= 1000
2. text 由一些用空格分隔的单词组成，每个单词都由小写英文字母组成
3. 1 <= first.length, second.length <= 10
4. first 和 second 由小写英文字母组成

**Answer**

*法一*

```js
var findOcurrences = function(text, first, second) {
    let arr = text.split(/\s+/);
    let res = []
    for (let i = 0; i < arr.length-2; i++) {
        if (arr[i] == first && arr[i+1]) {
            res.push(arr[i+2])
        }
    }
    return res
};

var text = "alice is a good girl she is a good student", first = "a", second = "good";
console.log(findOcurrences(text, first, second));
```

*法二：正则*

```js
var findOcurrences2 = function(text, first, second) {
    let res = []
    let pat = new RegExp(`(?<=\\b${first}\\s+${second}\\s+)\\w+`, 'gm')
    let item;
    while((item = pat.exec(text)) !== null) {
        res.push(item[0])
    }
    return res
};
```

1. (?<=) 表示向左看，用字符串模板时需要转义


2. `\b`[隐式位置](https://www.cnblogs.com/beiyi888/p/10281141.html)

如果不加 \b

例子 "aa good girl she is a good student"

会错误的匹配到 ["girl","student"]

而预期正确答案是 ["student"]


3. `修饰符m :` 表示执行多行匹配


# 1089. 复写零

给你一个长度固定的整数数组 arr，请你将该数组中出现的每个零都复写一遍，并将其余的元素向右平移。

注意：请不要在超过该数组长度的位置写入元素。

要求：请对输入的数组 就地 进行上述修改，不要从函数返回任何东西。

**示例 1：**

> 输入：[1,0,2,3,0,4,5,0]
> 输出：null
解释：调用函数后，输入的数组将被修改为：[1,0,0,2,3,0,0,4]

**示例 2：**

> 输入：[1,2,3]
> 输出：null
解释：调用函数后，输入的数组将被修改为：[1,2,3]

**提示：**

1. 1 <= arr.length <= 10000
2. 0 <= arr[i] <= 9

**Answer**

```js
var duplicateZeros = function(arr) {
    let len = arr.length;
    for (let i = 0; i < len; i++) {
        if (arr[i] == 0) {
            arr.splice(i, 0, 0)
            arr.pop()
            i++
        }
    }
    return arr
};
var arr = [1,0,2,3,0,4,5,0]
console.log(duplicateZeros(arr));
```

# 1103. 分糖果 II

排排坐，分糖果。

我们买了一些糖果 candies，打算把它们分给排好队的 n = num_people 个小朋友。

给第一个小朋友 1 颗糖果，第二个小朋友 2 颗，依此类推，直到给最后一个小朋友 n 颗糖果。

然后，我们再回到队伍的起点，给第一个小朋友 n + 1 颗糖果，第二个小朋友 n + 2 颗，依此类推，直到给最后一个小朋友 2 * n 颗糖果。

重复上述过程（每次都比上一次多给出一颗糖果，当到达队伍终点后再次从队伍起点开始），直到我们分完所有的糖果。注意，就算我们手中的剩下糖果数不够（不比前一次发出的糖果多），这些糖果也会全部发给当前的小朋友。

返回一个长度为 num_people、元素之和为 candies 的数组，以表示糖果的最终分发情况（即 ans[i] 表示第 i 个小朋友分到的糖果数）。

**示例 1：**

> 输入：candies = 7, num_people = 4
> 输出：[1,2,3,1]
解释：
第一次，ans[0] += 1，数组变为 [1,0,0,0]。
第二次，ans[1] += 2，数组变为 [1,2,0,0]。
第三次，ans[2] += 3，数组变为 [1,2,3,0]。
第四次，ans[3] += 1（因为此时只剩下 1 颗糖果），最终数组变为 [1,2,3,1]。

**示例 2：**

> 输入：candies = 10, num_people = 3
> 输出：[5,2,3]
解释：
第一次，ans[0] += 1，数组变为 [1,0,0]。
第二次，ans[1] += 2，数组变为 [1,2,0]。
第三次，ans[2] += 3，数组变为 [1,2,3]。
第四次，ans[0] += 4，最终数组变为 [5,2,3]。
 
**提示：**

- 1 <= candies <= 10^9
- 1 <= num_people <= 1000

**Answer**

```js
/**
 * @param {number} candies
 * @param {number} num_people
 * @return {number[]}
 */
var distributeCandies = function(candies, num_people) {
    let i = 0;
    let index = 0;
    let res = new Array(num_people).fill(0)
    let left = candies
    while(left > 0) {
        i++
        if (index >= num_people) index = 0
            if (left < i) {
                res[index] += left
            } else {
                res[index] += i
            }
        left -= i
        index++
    }
    return res
};
var candies = 10, num_people = 3
console.log(distributeCandies(candies, num_people));
```

# 1108. IP 地址无效化

**Answer**

```js
/**
 * @param {string} address
 * @return {string}
 */
var defangIPaddr = function(address) {
    return address.replace(/[.]/g, '[.]')
};
var address = "255.100.50.0"
console.log(defangIPaddr(address));
```

# 1122. 数组的相对排序

给你两个数组，arr1 和 arr2，

arr2 中的元素各不相同
arr2 中的每个元素都出现在 arr1 中
对 arr1 中的元素进行排序，使 arr1 中项的相对顺序和 arr2 中的相对顺序相同。未在 arr2 中出现过的元素需要按照升序放在 arr1 的末尾。

**示例：**

> 输入：arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
> 输出：[2,2,2,1,4,3,3,9,6,7,19]

**提示：**

1. arr1.length, arr2.length <= 1000
2. 0 <= arr1[i], arr2[i] <= 1000
3. arr2 中的元素 arr2[i] 各不相同
4. arr2 中的每个元素 arr2[i] 都出现在 arr1 中

**Answer**

```js
var relativeSortArray = function(arr1, arr2) {
    // arr1 中没有出现在 arr2 中的元素
    let arr3 = []
    let map = new Map()
    for(let i = 0; i < arr1.length; i++) {
    	let index = arr2.indexOf(arr1[i])
    	if (index != -1) {
    		if (!map.has(arr1[i])) {
    			map.set(arr1[i], true)
    			arr2.splice(index,1, arr1[i])
    		} else {
    			arr2.splice(index,0, arr1[i])
    		}
    	} else {
    		arr3.push(arr1[i])
    	}
    }
    arr3.sort((a, b) => a - b)
    return arr2.concat(arr3)
};
var arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6]
console.log(relativeSortArray(arr1, arr2));
```

# 1128. 等价多米诺骨牌对的数量

给你一个由一些多米诺骨牌组成的列表 dominoes。

如果其中某一张多米诺骨牌可以通过旋转 0 度或 180 度得到另一张多米诺骨牌，我们就认为这两张牌是等价的。

形式上，dominoes[i] = [a, b] 和 dominoes[j] = [c, d] 等价的前提是 a==c 且 b==d，或是 a==d 且 b==c。

在 0 <= i < j < dominoes.length 的前提下，找出满足 dominoes[i] 和 dominoes[j] 等价的骨牌对 (i, j) 的数量。

**示例：**

> 输入：dominoes = [[1,2],[2,1],[3,4],[5,6]]
> 输出：1

**提示：**

- 1 <= dominoes.length <= 40000
- 1 <= dominoes[i][j] <= 9

**Answer**

```js
var numEquivDominoPairs = function(dominoes) {
    let count = 0
    let map = new Map()
    for (let i = 0; i < dominoes.length; i++) {
        if (dominoes[i][0] > dominoes[i][1]) {
            [dominoes[i][0], dominoes[i][1]] = [dominoes[i][1], dominoes[i][0]]
        }
        let key = dominoes[i][0] + '-' + dominoes[i][1]
        if (!map.has(key)) {
            map.set(key,0)
        } else {
            map.set(key,map.get(key) + 1)
        }
    }
    for (let val of map.values()) {
        count += val * (val+1) / 2
    }
    return count
};
//var dominoes = [[7,8],[1,2],[2,1],[3,4],[5,6]]
var dominoes = [[1,2],[1,2],[1,1],[1,2],[2,2]]
console.log(numEquivDominoPairs(dominoes));
```

# 1137. 第 N 个泰波那契数

泰波那契序列 Tn 定义如下： 

T0 = 0, T1 = 1, T2 = 1, 且在 n >= 0 的条件下 Tn+3 = Tn + Tn+1 + Tn+2

给你整数 n，请返回第 n 个泰波那契数 Tn 的值。

**示例 1：**

> 输入：n = 4
> 输出：4
解释：
T_3 = 0 + 1 + 1 = 2
T_4 = 1 + 1 + 2 = 4

**示例 2：**

> 输入：n = 25
> 输出：1389537

**提示：**

- 0 <= n <= 37
- 答案保证是一个 32 位整数，即 answer <= 2^31 - 1。

**Answer**

```js
var tribonacci = function(n) {
    let res = [0,1,1]
    for (let i = 3; i <= n; i++) {
        res[i] = res[i-1] + res[i-2] + res[i-3]
    }
    return res[n]
};
var n = 25
console.log(tribonacci(n));
```

# 1154. 一年中的第几天

给你一个按 YYYY-MM-DD 格式表示日期的字符串 date，请你计算并返回该日期是当年的第几天。

通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。

**示例 1：**

> 输入：date = "2019-01-09"
> 输出：9

**示例 2：**

> 输入：date = "2019-02-10"
> 输出：41

**示例 3：**

> 输入：date = "2003-03-01"
> 输出：60

**示例 4：**

> 输入：date = "2004-03-01"
> 输出：61

**提示：**

1. date.length == 10
2. date[4] == date[7] == '-'，其他的 date[i] 都是数字。
3. date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日。

**Answer**

```js
var dayOfYear = function(date) {
	let [year, month, day] = date.split('-').map((item) => parseInt(item))
    let months = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    if (year != 1900 && year % 4 == 0) {
    	months[2] += 1
    }
    let sum = 0
    for (let i = 0; i < month; i++) {
        sum += months[i]
    }
    return sum + day
};
var date = "2019-02-10"
console.log(dayOfYear(date));
```

# 1160. 拼写单词

给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。

假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。

注意：每次拼写时，chars 中的每个字母都只能用一次。

返回词汇表 words 中你掌握的所有单词的 长度之和。

**示例 1：**

> 输入：words = ["cat","bt","hat","tree"], chars = "atach"
> 输出：6
解释： 
可以形成字符串 "cat" 和 "hat"，所以答案是 3 + 3 = 6。

**示例 2：**

> 输入：words = ["hello","world","leetcode"], chars = "welldonehoneyr"
> 输出：10
解释：
可以形成字符串 "hello" 和 "world"，所以答案是 5 + 5 = 10。
 
**提示：**

1. 1 <= words.length <= 1000
2. 1 <= words[i].length, chars.length <= 100
3. 所有字符串中都仅包含小写英文字母

**Answer**

```js
var countCharacters = function(words, chars) {
    let res = 0
    for (let i = 0; i < words.length; i++) {
        let chars2 = chars;
        let flag = true;
        for (let j = 0; j < words[i].length; j++) {
            let index = chars2.indexOf(words[i][j])
            if (index !== -1) {
                chars2 = chars2.substr(0, index) + chars2.substr(index+1)
            } else {
                flag = false
            }
        }
        if (flag) {
            res += words[i].length
        }
    }
    return res
};
var words = ["hello","world","leetcode"], chars = "welldonehoneyr"
console.log(countCharacters(words, chars));
```

# 1175. 质数排列

请你帮忙给从 1 到 n 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。

让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。

由于答案可能会很大，所以请你返回答案 模 mod 10^9 + 7 之后的结果即可。

**示例 1：**

> 输入：n = 5
> 输出：12
解释：举个例子，[1,2,5,4,3] 是一个有效的排列，但 [5,2,3,4,1] 不是，因为在第二种情况里质数 5 被错误地放在索引为 1 的位置上。

**示例 2：**

> 输入：n = 100
> 输出：682289015

**提示：**

- 1 <= n <= 100

**Answer**

- 素数的全排列方式总数对于`10**9+7`的余数`a`
- 非素数的全排列方式总数对于`10**9+7`的余数`b`

若直接计算 `(a*b)%(10**9+7)`时由于数位溢出，导致计算结果不准确，此不准确结果为：682289019
因此最终的a*b乘法应该将其中的一个数拆为两部分，分别相乘并取余：

**js大数相乘并取余**

```js
let MOD = 10**9+7;
function multi(a,b){
    //将b拆成2部分
    let t=Math.floor(b/100000),
        t2=b % 100000
    let sum=0
    for(let i=0;i<t;i++){
      sum=(sum+100000*a) % MOD
    }
    sum=(sum+t2*a)%MOD
    return sum
}
```

**最终代码为：**

```js
var numPrimeArrangements = function(n) {
    const MOD = 10**9+7;
    // 小于等于n的质数有多少个
    // 厄拉多塞筛法
     var numPrime = function(n) {
        let arr = []
        let count = 0
        for (let i = 2; i <= n; i++) {
            if (!arr[i]) {
                count++
                for (let j = i * 2; j <= n; j = j + i) {
                    arr[j] = true
                }
            }
        }
        return count
    }
    // 排列组合
    var pailie = function(n) {
        let res = 1;
        while(n > 1) {
            // res *= n
            res = res * n % (10**9 + 7)
            n--
        }
        return res
    }
    // 质数个数
    let primeNum = numPrime(n)
    // 合数个数
    let composite = n - primeNum;

    let a = pailie(primeNum) 
    let b = pailie(composite)

    function multi(a,b){
        //将b拆成2部分
        let t = Math.floor(b / 100000),
            t2 = b % 100000
        let sum = 0
        for(let i = 0; i < t; i++){
          sum = (sum + 100000 * a) % MOD
        }
        sum = (sum + t2 * a) % MOD
        return sum
    }
    return multi(a,b)
};
var n = 100
console.log(numPrimeArrangements(n));
```

**排列组合**

```js
function A(n,m){
   return (m===0?1:A(n,m-1)*(n-m+1));
}
```

# 1184. 公交站间的距离

环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。

环线上的公交车都可以按顺时针和逆时针的方向行驶。

返回乘客从出发点 start 到目的地 destination 之间的最短距离。 

示例 1：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1.jpg)

> 输入：distance = [1,2,3,4], start = 0, destination = 1
> 输出：1
解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。
 

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-1.jpg)

> 输入：distance = [1,2,3,4], start = 0, destination = 2
> 输出：3
解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。

**示例 3：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/09/08/untitled-diagram-1-2.jpg)

> 输入：distance = [1,2,3,4], start = 0, destination = 3
> 输出：4
解释：公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。

**提示：**

- 1 <= n <= 10^4
- distance.length == n
- 0 <= start, destination < n
- 0 <= distance[i] <= 10^4

**Answer**

```js
var distanceBetweenBusStops = function(distance, start, destination) {
    if (start > destination) {
        [start, destination] = [destination, start]
    }

    // 环形总和
    let total = 0;
    distance.forEach((i) => total += i)

    // 顺时针的和
    let sum = 0
    for (let i = start; i < destination; i++) {
        sum += distance[i]
    }
    
    return Math.min(sum, total-sum)
};
var distance = [1,2,3,4], start = 0, destination = 3
console.log(distanceBetweenBusStops(distance, start, destination));
```

# 1185. 一周中的第几天

给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。

输入为三个整数：day、month 和 year，分别表示日、月、年。

您返回的结果必须是这几个值中的一个 {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}。

**示例 1：**

> 输入：day = 31, month = 8, year = 2019
> 输出："Saturday"

**示例 2：**

> 输入：day = 18, month = 7, year = 1999
> 输出："Sunday"

**示例 3：**

> 输入：day = 15, month = 8, year = 1993
> 输出："Sunday"

**提示：**

给出的日期一定是在 1971 到 2100 年之间的有效日期。

**Answer**

```js
var dayOfTheWeek = function(day, month, year) {
    const m ={0:"Sunday", 1:"Monday", 2:"Tuesday", 3:"Wednesday", 4:"Thursday", 5:"Friday", 6:"Saturday"}
    return m[new Date(`${year}-${month}-${day}`).getDay()]
};
var day = 31, month = 8, year = 2019
console.log(dayOfTheWeek(day, month, year));
```

# 1189. “气球” 的最大数量

给你一个字符串 text，你需要使用 text 中的字母来拼凑尽可能多的单词 "balloon"（气球）。

字符串 text 中的每个字母最多只能被使用一次。请你返回最多可以拼凑出多少个单词 "balloon"。

**示例 1：**

> 输入：text = "nlaebolko"
> 输出：1

**示例 2：**

> 输入：text = "loonbalxballpoon"
> 输出：2

**示例 3：**

> 输入：text = "leetcode"
> 输出：0 

**提示：**

- 1 <= text.length <= 10^4
- text 全部由小写英文字母组成

**Answer**

```js
var maxNumberOfBalloons = function(text) {
    let map = new Map()
    let arr = text.split('')
    arr.forEach((item) => {
        if (/[ban]/.test(item)) {
            if (!map.has(item)) {
                map.set(item, 1)
            } else {
                map.set(item, map.get(item)+1)
            }
        } else if (/[lo]/.test(item)) {
            if (!map.has(item)) {
                map.set(item, 0.5)
            } else {
                map.set(item, map.get(item)+0.5)
            }
        }
    })
    let min = Math.min.apply(Math, ([...map.values()]))
    if (map.size < 5) {
    	return 0
    } else {
    	return parseInt(min)
    }
};
var text = "lonbalxballpoon"
console.log(maxNumberOfBalloons(text));
```

# 1200. 最小绝对差

给你个整数数组 arr，其中每个元素都 不相同。

请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。

**示例 1：**

> 输入：arr = [4,2,1,3]
> 输出：[[1,2],[2,3],[3,4]]

**示例 2：**

> 输入：arr = [1,3,6,10,15]
> 输出：[[1,3]]

**示例 3：**

> 输入：arr = [3,8,-10,23,19,-4,-14,27]
> 输出：[[-14,-10],[19,23],[23,27]]
 
**提示：**

- 2 <= arr.length <= 10^5
- -10^6 <= arr[i] <= 10^6

**Answer**


```js
var minimumAbsDifference = function(arr) {
    arr.sort((a, b) => a - b)
    let res = []
    let minDiff = arr[1] - arr[0]
    for (let i = 1; i < arr.length - 1; i++) {
        minDiff = Math.min(arr[i+1] - arr[i], minDiff)
    }
    for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i+1] - arr[i] == minDiff) {
            res.push([arr[i], arr[i+1]])
        }
    }
    return res
};
var arr = [3,8,-10,23,19,-4,-14,27]
console.log(minimumAbsDifference(arr));
```

# 1217. 玩筹码

数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。

你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：

将第 i 个筹码向左或者右移动 2 个单位，代价为 0。
将第 i 个筹码向左或者右移动 1 个单位，代价为 1。
最开始的时候，同一位置上也可能放着两个或者更多的筹码。

返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。

**示例 1：**

> 输入：chips = [1,2,3]
> 输出：1
解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。

**示例 2：**

> 输入：chips = [2,2,2,3,3]
> 输出：2
解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。
 
**提示：**

- 1 <= chips.length <= 100
- 1 <= chips[i] <= 10^9

**Answer**

chips = [1, 2, 2, 2, 3, 15, 23] 意味着位置1有1个筹码，位置2有3个筹码，同样位置3、15、23各有1个筹码。

把所有筹码移动到一个位置，移动两步代价为0，那其实我就可以把所有“奇数位置”筹码移动到一个点A（奇数位置），且不必花费任何代价；同理，所有“偶数位置”的筹码移动到点B（偶数位置）也不需要任何代价。最终就是看A,B两点谁的筹码数多，把少的筹码移动到多的筹码的位置，每一个筹码的代价都是1。

```js
var minCostToMoveChips = function(chips) {
    let odd = 0
    let even = 0
    for (let i = 0; i < chips.length; i++) {
        if (chips[i] % 2 == 0) {
            even++
        } else {
            odd++
        }
    }
    return Math.min(even, odd)
};
var chips = [2,2,2,3,3]
console.log(minCostToMoveChips(chips));
```

# 1221. 分割平衡字符串

在一个「平衡字符串」中，'L' 和 'R' 字符的数量是相同的。

给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。

返回可以通过分割得到的平衡字符串的最大数量。

**示例 1：**

> 输入：s = "RLRRLLRLRL"
> 输出：4
解释：s 可以分割为 "RL", "RRLL", "RL", "RL", 每个子字符串中都包含相同数量的 'L' 和 'R'。

**示例 2：**

> 输入：s = "RLLLLRRRLR"
> 输出：3
解释：s 可以分割为 "RL", "LLLRRR", "LR", 每个子字符串中都包含相同数量的 'L' 和 'R'。

**示例 3：**

> 输入：s = "LLLLRRRR"
> 输出：1
解释：s 只能保持原样 "LLLLRRRR".

**提示：**

- 1 <= s.length <= 1000
- s[i] = 'L' 或 'R'

**Answer**

```js
var balancedStringSplit = function(s) {
    let num = 0
    let res = 0;
    for(let i = 0; i < s.length; ++i){
        if (s[i] == 'R') {
            num++;
        } else {
            num--;
        }
        if (num==0) {
            res++;
        }
    }
    return res;
};

var s = "RLLLLRRRLR"
console.log(balancedStringSplit(s));
```

# 1232. 缀点成线

在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。

请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。 

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-2.jpg)

> 输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
> 输出：true

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/10/19/untitled-diagram-1.jpg)

> 输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
> 输出：false
 

**提示：**

- 2 <= coordinates.length <= 1000
- coordinates[i].length == 2
- -10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4
- coordinates 中不含重复的点

**Answer**

```js
var checkStraightLine = function(coordinates) {
    for (let i = 1; i < coordinates.length-1; i++) {
        let y1 = coordinates[i][1] - coordinates[0][1]
        let x1 = coordinates[i][0] - coordinates[0][0]
        let y2 = coordinates[i+1][1] - coordinates[i][1]
        let x2 = coordinates[i+1][0] - coordinates[i][0]
        if (y1*x2 !== x1*y2) {
            return false
        }
    }
    return true
};

var coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
console.log(checkStraightLine(coordinates));
```

# 1252. 奇数值单元格的数目

给你一个 n 行 m 列的矩阵，最开始的时候，每个单元格中的值都是 0。

另有一个索引数组 indices，indices[i] = [ri, ci] 中的 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。

你需要将每对 [ri, ci] 指定的行和列上的所有单元格的值加 1。

请你在执行完所有 indices 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。

**示例 1：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e1.png)

> 输入：n = 2, m = 3, indices = [[0,1],[1,1]]
> 输出：6
解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。
第一次增量操作后得到 [[1,2,1],[0,1,0]]。
最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。

**示例 2：**

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/11/06/e2.png)

> 输入：n = 2, m = 2, indices = [[1,1],[0,0]]
> 输出：0
解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。
 
**提示：**

- 1 <= n <= 50
- 1 <= m <= 50
- 1 <= indices.length <= 100
- 0 <= indices[i][0] < n
- 0 <= indices[i][1] < m

**Answer**

```js
var oddCells = function(n, m, indices) {
    let arr = []
    let res = 0
    for (let i = 0; i < n; i++) {
        let temp = []
        for (let j = 0; j < m; j++) {
            temp[j] = 0
        }
        arr.push(temp)
    }
    for (let i = 0; i < indices.length; i++) {
        let row = indices[i][0]
        let col = indices[i][1]
        arr[row].forEach((item, index) => {
            arr[row][index] += 1
        })
        arr.forEach((item, index) => {
            arr[index][col] += 1
        })
    }
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < m; j++) {
            if (arr[i][j] % 2 == 1) {
                res++
            }
        }
    }
    return res
};

var n = 2, m = 3, indices = [[0,1],[1,1]]
console.log(oddCells(n, m, indices));
```

# 1275. 找出井字棋的获胜者

A 和 B 在一个 3 x 3 的网格上玩井字棋。

井字棋游戏的规则如下：

玩家轮流将棋子放在空方格 (" ") 上。
第一个玩家 A 总是用 "X" 作为棋子，而第二个玩家 B 总是用 "O" 作为棋子。
"X" 和 "O" 只能放在空方格中，而不能放在已经被占用的方格上。
只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。
如果所有方块都放满棋子（不为空），游戏也会结束。
游戏结束后，棋子无法再进行任何移动。
给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。

如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 "Draw"；如果仍会有行动（游戏未结束），则返回 "Pending"。

你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。

**示例 1：**

> 输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]
> 输出："A"
解释："A" 获胜，他总是先走。
"X  "    "X  "    "X  "    "X  "    "X  "
"   " -> "   " -> " X " -> " X " -> " X "
"   "    "O  "    "O  "    "OO "    "OOX"

**示例 2：**

> 输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]
> 输出："B"
解释："B" 获胜。
"X  "    "X  "    "XX "    "XXO"    "XXO"    "XXO"
"   " -> " O " -> " O " -> " O " -> "XO " -> "XO " 
"   "    "   "    "   "    "   "    "   "    "O  "

**示例 3：**

> 输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]
> 输出："Draw"
输出：由于没有办法再行动，游戏以平局结束。
"XXO"
"OOX"
"XOX"

**示例 4：**

输入：moves = [[0,0],[1,1]]
输出："Pending"
解释：游戏还没有结束。
"X  "
" O "
"   "

**提示：**

- 1 <= moves.length <= 9
- moves[i].length == 2
- 0 <= moves[i][j] <= 2
- moves 里没有重复的元素。
- moves 遵循井字棋的规则。

**Answer**

```js
var tictactoe = function(moves) {
    let A = [];
    let B = [];
    let isAWin = false
    let isBWin = false
    let len = moves.length
    for (let i = 0; i < len; i++) {
        if (i % 2 == 0) {
            A.push(moves[i])
        } else {
            B.push(moves[i])
        }
    }
    let Alen = A.length
    let Blen = B.length
    if (Alen >= 3) {
        for (let i = 0; i < Alen; i++) {
            for (let j = 0; j < Alen; j++) {
                if (j !== i) {
                    for (let k = 0; k < Alen; k++) {
                        if (k !== i && k !== j) {
                            if ((A[j][1] - A[i][1]) * (A[k][0] - A[j][0]) == (A[j][0] - A[i][0]) * (A[k][1] - A[j][1])) {
                                isAWin = true
                                break;
                            }
                        }
                    }
                }
            }
        } 
    }
    if (Blen >= 3) {
        for (let i = 0; i < Blen; i++) {
            for (let j = 0; j < Blen; j++) {
                if (j !== i) {
                    for (let k = 0; k < Blen; k++) {
                        if (k !== i && k !== j) {
                            if ((B[j][1] - B[i][1]) * (B[k][0] - B[j][0]) == (B[j][0] - B[i][0]) * (B[k][1] - B[j][1])) {
                                isBWin = true
                                break;
                            }
                        }
                    }
                }
            }
        } 
    }
    if (isAWin) {
        return 'A'
    } else if (isBWin) {
        return 'B'
    } else if (len == 9) {
        return 'Draw'
    } else {
        return 'Pending'
    }

};

var moves = [[0,0],[1,1]]
console.log(tictactoe(moves));
```

